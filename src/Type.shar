module STD

//@All types that were created using the "type" keyword are automatically placed in the "STD::Type" group.
export group Type

#alwaysinline nothrow
def type_rc_free(type $Any)
    llvm
        %##nreg##type as list## = insertvalue {i64, i32} %0, i32 ##tnum##STD::List##, 1
        %##nreg##unneeded## = call {i64, i32} ##ancntfunc##STD::shar__rc_free.STD::List##({i64, i32} %##reg##type as list##)
        ret {i64, i32} zeroinitializer

#alwaysinline nothrow
def type_rc_use(type $Any)
    llvm
        %##nreg##type as list## = insertvalue {i64, i32} %0, i32 ##tnum##STD::List##, 1
        %##nreg##unneeded## = call {i64, i32} ##ancntfunc##STD::shar__rc_use.STD::List##({i64, i32} %##reg##type as list##)
        ret {i64, i32} zeroinitializer

#alwaysinline nothrow
def type_to_const(type $Any)
    llvm
        %##nreg##type as list## = insertvalue {i64, i32} %0, i32 ##tnum##STD::List##, 1
        %##nreg##unneeded## = call {i64, i32} ##ancntfunc##STD::shar__to_const.STD::List##({i64, i32} %##reg##type as list##)
        ret {i64, i32} zeroinitializer

#alwaysinline nothrow
def type_use?(type $Any) Bool
    llvm
        %##nreg##type as list## = insertvalue {i64, i32} %0, i32 ##tnum##STD::List##, 1
        %##nreg##result## = call {i64, i32} ##ancntfunc##STD::use?.STD::List##({i64, i32} %##reg##type as list##)
        ret {i64, i32} %##reg##result##

#alwaysinline nothrow
def type_constant?(type $Any) Bool
    llvm
        %##nreg##type as list## = insertvalue {i64, i32} %0, i32 ##tnum##STD::List##, 1
        %##nreg##result## = call {i64, i32} ##ancntfunc##STD::constant?.STD::List##({i64, i32} %##reg##type as list##)
        ret {i64, i32} %##reg##result##

#alwaysinline nothrow
def type_clone(type $Any) $Any
    llvm
        %##nreg##type as list## = insertvalue {i64, i32} %0, i32 ##tnum##STD::List##, 1
        %##nreg##result list## = call {i64, i32} ##ancntfunc##STD::clone.STD::List##({i64, i32} %##reg##type as list##)
        %##nreg##result list value## = extractvalue {i64, i32} %##reg##result list##, 0
        %##nreg##result## = insertvalue {i64, i32} %0, i64 %##reg##result list value##, 0
        ret {i64, i32} %##reg##result##

//@The function converts the list to type.
#this(Type) alwaysinline
export def fromList(noread type This, list List) This
    llvm
        %##nreg##unneeded## = call {i64, i32} ##ancntfunc##STD::shar__rc_use.STD::List##({i64, i32} %1)
        %##nreg##result value## = extractvalue {i64, i32} %1, 0
        %##nreg##result## = insertvalue {i64, i32} %0, i64 %##reg##result value##, 0
        ret {i64, i32} %##reg##result##

//@The function converts the type to a list.
#alwaysinline
export def toList(type $Type) List
    llvm
        %##nreg##result value## = extractvalue {i64, i32} %0, 0
        %##nreg##result## = insertvalue {i64, i32} {i64 0, i32 ##tnum##STD::List##}, i64 %##reg##result value##, 0
        %##nreg##unneeded## = call {i64, i32} ##ancntfunc##STD::shar__rc_use.STD::List##({i64, i32} %##reg##result##)
        ret {i64, i32} %##reg##result##

//@The function is the same as the "STD::getItem" function for list.
#alwaysinline
export def typeGetItem(type $Type, index Int) $Any
    llvm
        %##nreg##type value## = extractvalue {i64, i32} %0, 0
        %##nreg##type as list## = insertvalue {i64, i32} {i64 0, i32 ##tnum##STD::List##}, i64 %##reg##type value##, 0
        %##nreg##result## = call {i64, i32} ##ancfunc##STD::shar__sugar__getItem.STD::List##({i64, i32} %##reg##type as list##, {i64, i32} %1)
        ret {i64, i32} %##reg##result##

//@The function is the same as the "STD::setItem" function for list.
#alwaysinline unsafewrite
export def typeSetItem(write type $Type, index Int, newItem $Any)
    llvm
        %##nreg##ro type## = load {i64, i32}, {i64, i32}* %0, align 8
        %##nreg##type value## = extractvalue {i64, i32} %##reg##ro type##, 0
        %##nreg##type of type## = extractvalue {i64, i32} %##reg##ro type##, 1
        %##nreg##type as list## = insertvalue {i64, i32} {i64 0, i32 ##tnum##STD::List##}, i64 %##reg##type value##, 0
        store {i64, i32} %##reg##type as list##, {i64, i32}* %0, align 8
        %##nreg##result## = call {i64, i32} ##ancfunc##STD::setItem.STD::List##({i64, i32}* %0, {i64, i32} %1, {i64, i32} %2)
        %##nreg##new ro type## = load {i64, i32}, {i64, i32}* %0, align 8
        %##nreg##new type## = insertvalue {i64, i32} %##reg##new ro type##, i32 %##reg##type of type##, 1
        store {i64, i32} %##reg##new type##, {i64, i32}* %0, align 8
        ret {i64, i32} %##reg##result##

//@The function is the same as the "STD::put" function for list.
#alwaysinline unsafewrite
export def typePut(write type $Type, index Int, newItem $Any) $Any
    llvm
        %##nreg##ro type## = load {i64, i32}, {i64, i32}* %0, align 8
        %##nreg##type value## = extractvalue {i64, i32} %##reg##ro type##, 0
        %##nreg##type of type## = extractvalue {i64, i32} %##reg##ro type##, 1
        %##nreg##type as list## = insertvalue {i64, i32} {i64 0, i32 ##tnum##STD::List##}, i64 %##reg##type value##, 0
        store {i64, i32} %##reg##type as list##, {i64, i32}* %0, align 8
        %##nreg##result## = call {i64, i32} ##ancfunc##STD::put.STD::List##({i64, i32}* %0, {i64, i32} %1, {i64, i32} %2)
        %##nreg##new ro type## = load {i64, i32}, {i64, i32}* %0, align 8
        %##nreg##new type## = insertvalue {i64, i32} %##reg##new ro type##, i32 %##reg##type of type##, 1
        store {i64, i32} %##reg##new type##, {i64, i32}* %0, align 8
        ret {i64, i32} %##reg##result##
