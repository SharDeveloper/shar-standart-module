module STD

//@A type that is a member of the "STD::Array" group.
export primitive Array

//@Members of the "STD::Array" group are types whose objects contain zero or more objects (called "items") of the same type grouped into one object.
//@The type of the array items can be any type.
//@If the array is empty, then it is considered that the type of its items is "STD::Nothing".
//@If the array is not empty, then the item type cannot be "STD::Nothing".
//@If the array is empty, or the type of an array item can be compared by more or less, then this array can be compared by more or less with another array whose item types are the same as the current array, or if the second array is empty.
//@If array "a" is empty, and array "b" is not empty, then array "a" is less than array "b".
//@If array "a" has zero or more items equal to the same number of items in array "b", and the next item of array "a" is less than the next item of array "b", then array "a" is less than array "b".
//@If array "a" is equal to the beginning of array "b", but at the same time array "b" contains more items than array "a", then array "a" is less than array "b".
//@When comparing two arrays for more, less, equal, the comparison occurs from the beginning of the array to the end. Comparison takes place until the result is clear.
//@Functions "STD::shar__sugar__less", "STD::shar__sugar__great", "STD::shar__sugar__lessOrEqual", "STD::shar__sugar__greatOrEqual", "STD::shar__sugar__add", "STD::shar__sugar__addSet" return an error with code "enum::STD::error_invalidType" if the arrays passed as arguments to these functions are not empty and have different types of items.
export group Array: Container, Ordered, ItemTypeNumber

#override(STD)
def shar__rc_free(array Array)
    const counter Int = array.unsafe_getI64(0)
    if counter > 1
        array.unsafe_setI64(0, counter - 1)
    elif counter == 1
        for :(index Int = 0) index < array.length~(); index++
            array.unsafe_array_getItem(index).shar__rc_free()
        array.unsafe_free()

#override(STD) alwaysinline
def shar__rc_use(array Array)
    const counter Int = array.unsafe_getI64(0)
    if counter != 0
        array.unsafe_setI64(0, counter + 1)

#override(STD)
def shar__to_const(array Array)
    if array.unsafe_getI64(0) != 0
        for :(index Int = 0) index < array.length~(); index++
            array.unsafe_array_getItem(index).shar__to_const()
        array.unsafe_setI64(0, 0)

#override(STD) alwaysinline nothrow
def use?(array Array) Bool
    return array.unsafe_getI64(0) != 1

#override(STD) alwaysinline nothrow
def constant?(array Array) Bool
    return array.unsafe_getI64(0) == 0

#override(STD) nothrow
def clone(array Array) Array
    var result Array = unsafe_array_createDummy(array.length~(), array.itemTypeNumber~())
    parse index, item = array
        result.unsafe_array_setItemInDummy(index, item)
    return result

attach Array to Equal

attach Array to Shar__sugar__equal
    #alwaysinline
    def shar__sugar__equal(array1, array2 Array) Bool
        return array1.length~() == array2.length~() && array1.partsEqual?(0, array2, 0, array1.length~())

attach Array to Shar__sugar__notEqual
    #alwaysinline
    def shar__sugar__notEqual(array1, array2 Array) Bool
        return !(array1 == array2)

attach Array to Ordered

attach Array to Shar__sugar__less
    #alwaysinline
    def shar__sugar__less(array1, array2 Array) Bool
        const generalLength Int = array1.length~().min(array2.length~())
        if generalLength != 0
            for :(index Int = 0) index < generalLength; index++
                const item1 $Any = array1[index]
                const item2 $Any = array2[index]
                if item1 < item2
                    return true
                elif item2 < item1
                    return false
        return array1.length~() < array2.length~()

attach Array to Shar__sugar__great
    #alwaysinline
    def shar__sugar__great(array1, array2 Array) Bool
        const generalLength Int = array1.length~().min(array2.length~())
        if generalLength != 0
            for :(index Int = 0) index < generalLength; index++
                const item1 $Any = array1[index]
                const item2 $Any = array2[index]
                if item1 > item2
                    return true
                elif item2 > item1
                    return false
        return array1.length~() > array2.length~()

attach Array to Shar__sugar__lessOrEqual
    #alwaysinline
    def shar__sugar__lessOrEqual(array1, array2 Array) Bool
        const generalLength Int = array1.length~().min(array2.length~())
        if generalLength != 0
            for :(index Int = 0) index < generalLength; index++
                const item1 $Any = array1[index]
                const item2 $Any = array2[index]
                if item1 < item2
                    return true
                elif item2 < item1
                    return false
        return array1.length~() <= array2.length~()

attach Array to Shar__sugar__greatOrEqual
    #alwaysinline
    def shar__sugar__greatOrEqual(array1, array2 Array) Bool
        const generalLength Int = array1.length~().min(array2.length~())
        if generalLength != 0
            for :(index Int = 0) index < generalLength; index++
                const item1 $Any = array1[index]
                const item2 $Any = array2[index]
                if item1 > item2
                    return true
                elif item2 > item1
                    return false
        return array1.length~() >= array2.length~()

attach Array to Shar__sugar__getRange
    #alwaysinline
    def shar__sugar__getRange(array Array, from, to Int) Array
        inthrow
            if !(from >= 0 && from <= to && to <= array.length~())
                throw(enum::error_outOfRange, "Out of range.")
        const length Int = to - from
        var result Array = []
        if length != 0
            result = unsafe_array_createDummy(length, array.itemTypeNumber~())
            for :(index Int = 0) index < length; index++
                result.unsafe_array_setItemInDummy(index, array[from + index])
        return result

attach Array to Shar__sugar__getItem
    #alwaysinline
    def shar__sugar__getItem(array Array, index Int) $Any
        inthrow
            if !index.inRange?(0, array.length~())
                throw(enum::error_outOfRange, "Out of range.")
        return array.unsafe_array_getItem(index)

#alwaysinline nothrow
def unsafe_array_getItem(array, index $Any) $Any
    var result $Any = array.unsafe_getI64(index + 3)
    result.unsafe_setType(array.unsafe_getI64(2))
    result.shar__rc_use()
    return result

attach Array to Shar__sugar__add
    #inline
    def shar__sugar__add(array, addedArray Array) Array
        if addedArray.empty?()
            return array
        if array.empty?()
            return addedArray
        inthrow
            if array.itemTypeNumber~() != addedArray.itemTypeNumber~()
                throw(enum::error_invalidType, "Invalid type.")
        var result Array = unsafe_array_createDummy(array.length~() + addedArray.length~(), array.itemTypeNumber~())
        parse index, item = array
            result.unsafe_array_setItemInDummy(index, item)
        parse index, item = addedArray
            result.unsafe_array_setItemInDummy(index + array.length~(), item)
        return result

attach Array to Shar__sugar__addSet
    #inline
    def shar__sugar__addSet(write array, addedArray Array)
        if addedArray.empty?()
            return
        if array.empty?()
            array = addedArray
            return
        inthrow
            if array.itemTypeNumber~() != addedArray.itemTypeNumber~()
                throw(enum::error_invalidType, "Invalid type.")
        if array.use?()
            array = array + addedArray
            return
        const startArrayLength Int = array.length~()
        const newLength Int = startArrayLength + addedArray.length~()
        array.unsafe_setI64(1, newLength)
        array.unsafe_realloc(newLength * 8 + 24)
        parse index, item = addedArray
            array.unsafe_array_setItemInDummy(startArrayLength + index, item)

attach Array to StringWriter
    //@The function returns an object of type "STD::String".
    def toString(array Array) String
        var result String = ""
        if array.empty?()
            result = "[]"
        else
            result = "["
            parse _, item = array
                result += item.toString().repackTo(String)
                result += ", "
            result.delete(result.length~() - 1, 1)
            result.unsafe_setI16(result.length~() + 7, ']')
        return result

attach Array to Hashable
    #alwaysinline
    def getHash(array Array) Int
        var result Int = array.length~()
        result += result << 10
        result ^= result >> 6
        parse _, item = array
            result += item.getHash()
            result += result << 10
            result ^= result >> 6
        result += result << 3
        result ^= result >> 11
        result += result << 15
        return result

    #alwaysinline
    def getRandomizedHash(array Array) Int
        const randomNumber Int = const::staticRandomNumber
        const rightShifts Int = (randomNumber & 0xf) + 32
        const leftShifts Int = ((randomNumber & 0xf0) >> 4) + 32
        var result Int = randomNumber + array.length~()
        result += result << 10
        result ^= result >> 6
        parse _, item = array
            result = (result >> rightShifts) + (result << leftShifts) + (result & 0xffffffff)
            result += item.getHash()
            result += result << 10
            result ^= result >> 6
        result += result << 3
        result ^= result >> 11
        result += result << 15
        return result

attach Array to Long
    #alwaysinline nothrow
    def length~(array Array) Int
        return array.unsafe_getI64(1)

attach Array to Empty
    #alwaysinline nothrow
    def createEmpty(noread type Array) Array
        return []

attach Array to Put
    #alwaysinline
    def put(write array Array, index Int, newItem $Any) $Any
        const oldItem $Any = array[index]
        inthrow
            if array.itemTypeNumber~() != newItem.typeNumber~()
                throw(enum::error_invalidType, "Invalid type.")
        if array.use?()
            array = array.clone()
        array.unsafe_array_setItem(index, newItem)
        return oldItem

attach Array to Iterable
    #alwaysinline nothrow
    def parse__init(array Array) Int
        return 0

    #alwaysinline nothrow
    def parse__predicate(array Array, index Int) Bool
        return index != array.length~()

    #alwaysinline unsafewrite nothrow
    def parse__next(array Array, write index Int)
        index++

    #alwaysinline nothrow
    def parse__get__key(array Array, index Int) Int
        return index

    #alwaysinline nothrow
    def parse__get__item(array Array, index Int) $Any
        return array[index]

attach Array to Container
    #inline
    def addItem(write array Array, newItem $Any)
        if array.empty?()
            array = [newItem]
            return
        inthrow
            if newItem.typeNumber~() != array.itemTypeNumber~()
                throw(enum::error_invalidType, "Invalid type.")
        const oldLength Int = array.length~()
        const newLength Int = oldLength + 1
        if array.use?()
            var newArray Array = unsafe_array_createDummy(newLength, newItem.typeNumber~())
            parse index, item = array
                newArray.unsafe_array_setItemInDummy(index, item)
            array = newArray
        else
            array.unsafe_setI64(1, newLength)
            array.unsafe_realloc(newLength * 8 + 24)
        array.unsafe_array_setItemInDummy(oldLength, newItem)

    #inline
    def addItem$(array Array, newItem $Any) Array
        inthrow
            if !(array.empty?() || newItem.typeNumber~() == array.itemTypeNumber~()) || newItem.nothing?()
                throw(enum::error_invalidType, "Invalid type.")
        var newArray Array = unsafe_array_createDummy(array.length~() + 1, newItem.typeNumber~())
        parse index, item = array
            newArray.unsafe_array_setItemInDummy(index, item)
        newArray.unsafe_array_setItemInDummy(array.length~(), newItem)
        return newArray

#alwaysinline nothrow
def unsafe_array_setItem(array, index, newItem $Any)
    const offset $Any = index + 3
    var oldItem $Any = array.unsafe_getI64(offset)
    oldItem.unsafe_setType(array.unsafe_getI64(2))
    newItem.shar__rc_use()
    array.unsafe_setI64(offset, newItem)

#alwaysinline nothrow
def unsafe_array_createDummy(length, itemTypeNumber $Any) Array
    var result $Any = unsafe_malloc(length * 8 + 24)
    result.unsafe_setI64(0, 1)
    result.unsafe_setI64(1, length)
    result.unsafe_setI64(2, itemTypeNumber)
    result.unsafe_setType(Array.typeNumber~())
    return result

#alwaysinline nothrow
def unsafe_array_setItemInDummy(array, index, item $Any)
    item.shar__rc_use()
    array.unsafe_setI64(index + 3, item)

attach Array to ItemTypeNumber
    #alwaysinline nothrow
    def itemTypeNumber~(array Array) Int
        return array.unsafe_getI64(2)

attach Array to Array

//@The function finds out if the type of array items is a member of the "STD::Independent" group.
#this(Array) alwaysinline
export def itemTypeIndependent?(array This) Bool
    if array.empty?()
        return false
    return array[0].inGroups?(Independent)

//@The function finds out if the type of array items is a member of the "STD::Equal" group.
#this(Array) alwaysinline
export def itemTypeInEqual?(array This) Bool
    if array.empty?()
        return false
    return array[0].inGroups?(Equal)

//@The function finds out if the type of array items is a member of the "STD::Ordered" group.
#this(Array) alwaysinline
export def itemTypeInOrdered?(array This) Bool
    if array.empty?()
        return false
    return array[0].inGroups?(Ordered)

//@The function returns a sorted array of the items of the array given as the first argument.
//@Sorting is performed in ascending order if the argument "rise" is equal to "true", otherwise the sorting is performed in descending order.
//@If the array items are not members of the group "STD::Ordered" then the function returns an error with the code "enum::STD::error_invalidType".
#this(Array)
export def sort$(array This, rise Bool) This
    var result This = array
    result.sort(rise)
    return result

//@The function sorts the array given as the first argument.
//@Sorting is performed in ascending order if the argument "rise" is equal to "true", otherwise the sorting is performed in descending order.
//@If the array items are not members of the group "STD::Ordered" then the function returns an error with the code "enum::STD::error_invalidType".
#this(Array)
export def sort(write array This, rise Bool)
    if array.empty?()
        return
    inthrow
        if !array.itemTypeInOrdered?()
            throw(enum::error_invalidType, "Invalid type.")
    return array.quicksort(0, array.length~(), rise, const::staticRandomNumber)

#this(Array)
def quicksort(write array This, beginIndex, endEdge Int, rise Bool, randomNumber Int)
    var leftIndex Int = beginIndex
    var rightEdge Int = endEdge
    for :(mainLoop)
        const rangeLength Int = rightEdge - leftIndex
        if rangeLength > 16
            const length25p Int = rangeLength >> 2
            const length75p Int = (length25p << 1) + length25p
            var randomIndex Int = (randomNumber & (rangeLength - 1))
            if randomIndex < length25p
                randomIndex += length25p
            elif randomIndex > length75p
                randomIndex -= length25p
            array.swap(leftIndex, randomIndex + leftIndex)
            const currentItem $Any = array[leftIndex]
            var currentIndex Int = leftIndex
            var oppositeIndex Int = rightEdge - 1
            var direction Int = -1
            var cmpModifier Bool = rise
            for :(loop)
                const oppositeItem $Any = array[oppositeIndex]
                if cmpModifier.select(oppositeItem <= currentItem, currentItem <= oppositeItem)
                    array.swap(currentIndex, oppositeIndex)
                    exchange(currentIndex, oppositeIndex)
                    direction = !direction
                    cmpModifier = !cmpModifier
                if (currentIndex - oppositeIndex).abs() == 1
                    end loop
                oppositeIndex += direction
            const leftRangeLength Int = currentIndex - leftIndex
            const rightRangeLength Int = rightEdge - currentIndex - 1
            var smallRangeLeftIndex Int = -1
            var smallRangeRightEdge Int = -1
            var smallRangeLength Int = -1
            var bigRangeLeftIndex Int = -1
            var bigRangeRightEdge Int = -1
            if leftRangeLength < rightRangeLength
                smallRangeLeftIndex = leftIndex
                smallRangeRightEdge = currentIndex
                smallRangeLength = leftRangeLength
                bigRangeLeftIndex = currentIndex + 1
                bigRangeRightEdge = rightEdge
            else
                smallRangeLeftIndex = currentIndex + 1
                smallRangeRightEdge = rightEdge
                smallRangeLength = rightRangeLength
                bigRangeLeftIndex = leftIndex
                bigRangeRightEdge = currentIndex
            leftIndex = bigRangeLeftIndex
            rightEdge = bigRangeRightEdge
            switch :(switch) smallRangeLength
            case 2
                const firstItem $Any = array[smallRangeLeftIndex]
                const secondItem $Any = array[smallRangeLeftIndex + 1]
                if (secondItem < firstItem) == rise
                    array.swap(smallRangeLeftIndex, smallRangeLeftIndex + 1)
            case 0, 1
                nothing
            default
                array.quicksort(smallRangeLeftIndex, smallRangeRightEdge, rise, randomNumber)
        else
            if rangeLength > 2
                array.heapSort(leftIndex, rightEdge, rangeLength, rise)
            elif rangeLength == 2
                const firstItem $Any = array[leftIndex]
                const secondItem $Any = array[leftIndex + 1]
                if (secondItem < firstItem) == rise
                    array.swap(leftIndex, leftIndex + 1)
            end mainLoop

#this(Array)
def heapSort(write array This, beginIndex, endEdge, count Int, rise Bool)
    for :(currentIndex Int = (count >> 1) + beginIndex - 1) currentIndex >= beginIndex; currentIndex--
        array.toHeap(currentIndex, beginIndex, endEdge, rise)
    for :(currentEdge Int = endEdge - 1) currentEdge >= beginIndex; currentEdge--
        array.swap(beginIndex, currentEdge)
        array.toHeap(beginIndex, beginIndex, currentEdge, rise)

#this(Array)
def toHeap(write array This, currentIndex, beginIndex, endEdge Int, rise Bool)
    var mutCurrentIndex Int = currentIndex
    for :(loop)
        var largestIndex Int = mutCurrentIndex
        const leftIndex Int = 2 * mutCurrentIndex - beginIndex + 1
        const rightIndex Int = leftIndex + 1
        if rightIndex < endEdge
            if  array[largestIndex] < array[rightIndex] == rise
                largestIndex = rightIndex
            if  array[largestIndex] < array[leftIndex] == rise
                largestIndex = leftIndex
        elif leftIndex < endEdge && (array[largestIndex] < array[leftIndex] == rise)
            largestIndex = leftIndex
        if largestIndex != mutCurrentIndex
            array.swap(mutCurrentIndex, largestIndex)
            mutCurrentIndex = largestIndex
        else
            end loop

#override(STD) alwaysinline
def partsEqual?(array1 Array, from1 Int, array2 Array, from2, length Int) Bool
    const array1Length Int = array1.length~()
    const array2Length Int = array2.length~()
    var result Bool = {
            from1 >= 0 && from1 <= array1Length &&
            from2 >= 0 && from2 <= array2Length &&
            length >= 0 && length <= (array1Length - from1).min(array2Length - from2) &&
            array1.itemTypeNumber~() == array2.itemTypeNumber~() &&
            (
                array1.itemTypeNumber~() == Nothing.typeNumber~() ||
                array2.itemTypeInEqual?()
            )
        }
    if result
        for :(offset Int = 0) offset < length; offset++
            result = array1[from1 + offset] == array2[from2 + offset]
            if !result
                end offset
    return result

#override(STD) alwaysinline
def swap(write array Array, position1, position2 Int)
    inthrow
        if !(position1.inRange?(0, array.length~()) && position2.inRange?(0, array.length~()))
            throw(enum::error_outOfRange, "Out of range.")
    if array.use?()
        array = array.clone()
    const items Int = array.unsafe_offsetI64(3)
    const tmpItem Int = items.unsafe_getI64(position1)
    items.unsafe_setI64(position1, items.unsafe_getI64(position2))
    items.unsafe_setI64(position2, tmpItem)

#override(STD)
def delete$(array Array, from, count Int) Array
    const oldLength Int = array.length~()
    const newLength Int = oldLength - count
    inthrow
        if {
            !(from >= 0 && from <= oldLength &&
            count >= 0 && count <= oldLength - from)
        }
            throw(enum::error_outOfRange, "Out of range.")
    if count == 0
        return array
    if newLength == 0
        return []
    var result Array = unsafe_array_createDummy(newLength, array.itemTypeNumber~())
    for :(index Int = 0) index < from; index++
        result.unsafe_array_setItemInDummy(index, array.unsafe_array_getItem(index))
    for :(index Int = from + count) index < array.length~(); index++
        result.unsafe_array_setItemInDummy(index - count, array.unsafe_array_getItem(index))
    return result

#override(STD)
def delete(write array Array, from, count Int)
    const oldLength Int = array.length~()
    inthrow
        if {
            !(from >= 0 && from <= oldLength &&
            count >= 0 && count <= oldLength - from)
        }
            throw(enum::error_outOfRange, "Out of range.")
    if count == 0
        return
    const newLength Int = oldLength - count
    if newLength == 0
        array = []
        return
    if array.use?()
        var newArray Array = unsafe_array_createDummy(newLength, array.itemTypeNumber~())
        for :(index Int = 0) index < from; index++
            newArray.unsafe_array_setItemInDummy(index, array.unsafe_array_getItem(index))
        for :(index Int = from + count) index < array.length~(); index++
            newArray.unsafe_array_setItemInDummy(index - count, array.unsafe_array_getItem(index))
        array = newArray
    else
        const edge Int = from + count
        for :(index Int = from) index < edge; index++
            array.unsafe_array_getItem(index).shar__rc_free()
        const lastPartIndex Int = edge
        const lastPartLength Int = oldLength - lastPartIndex
        const arrayItems Int = array.unsafe_offsetI64(3)
        unsafe_memmoveI64(arrayItems.unsafe_offsetI64(from), arrayItems.unsafe_offsetI64(lastPartIndex), lastPartLength)
        array.unsafe_setI64(1, newLength)
        array.unsafe_realloc(newLength * 8 + 24)

#override(STD) inline
def insert$(array Array, index Int, newItem $Any) Array
    const oldLength Int = array.length~()
    const newLength Int = oldLength + 1
    inthrow
        if !index.inRange?(0, newLength)
            throw(enum::error_outOfRange, "Out of range.")
        if !(array.empty?() || newItem.typeNumber~() == array.itemTypeNumber~()) || newItem.nothing?()
            throw(enum::error_invalidType, "Invalid type.")
    var result Array = unsafe_array_createDummy(newLength, newItem.typeNumber~())
    for :(arrayIndex Int = 0) arrayIndex < index; arrayIndex++
        result.unsafe_array_setItemInDummy(arrayIndex, array.unsafe_array_getItem(arrayIndex))
    result.unsafe_array_setItemInDummy(index, newItem)
    for :(arrayIndex Int = index) arrayIndex < oldLength; arrayIndex++
        result.unsafe_array_setItemInDummy(arrayIndex + 1, array.unsafe_array_getItem(arrayIndex))
    return result

#override(STD) inline
def insert(write array Array, index Int, newItem $Any)
    const oldLength Int = array.length~()
    const newLength Int = oldLength + 1
    inthrow
        if !index.inRange?(0, newLength)
            throw(enum::error_outOfRange, "Out of range.")
        if !(array.empty?() || newItem.typeNumber~() == array.itemTypeNumber~()) || newItem.nothing?()
            throw(enum::error_invalidType, "Invalid type.")
    if array.use?()
        var newArray Array = unsafe_array_createDummy(newLength, newItem.typeNumber~())
        for :(arrayIndex Int = 0) arrayIndex < index; arrayIndex++
            newArray.unsafe_array_setItemInDummy(arrayIndex, array.unsafe_array_getItem(arrayIndex))
        newArray.unsafe_array_setItemInDummy(index, newItem)
        for :(arrayIndex Int = index) arrayIndex < oldLength; arrayIndex++
            newArray.unsafe_array_setItemInDummy(arrayIndex + 1, array.unsafe_array_getItem(arrayIndex))
        array = newArray
    else
        array.unsafe_setI64(1, newLength)
        array.unsafe_realloc(newLength * 8 + 24)
        const arrayItems Int = array.unsafe_offsetI64(3)
        unsafe_memmoveI64(arrayItems.unsafe_offsetI64(index + 1), arrayItems.unsafe_offsetI64(index), oldLength - index)
        array.unsafe_array_setItemInDummy(index, newItem)

#override(STD) inline
def insertPart$(array Array, index Int, addedArray Array) Array
    const oldLength Int = array.length~()
    const addedLength Int = addedArray.length~()
    const newLength Int = oldLength + addedLength
    inthrow
        if !index.inRange?(0, oldLength + 1)
            throw(enum::error_outOfRange, "Out of range.")
    if addedLength == 0
        return array
    inthrow
        if !(oldLength == 0 || array.itemTypeNumber~() == addedArray.itemTypeNumber~())
            throw(enum::error_invalidType, "Invalid type.")
    var result Array = unsafe_array_createDummy(newLength, addedArray.itemTypeNumber~())
    for :(arrayIndex Int = 0) arrayIndex < index; arrayIndex++
        result.unsafe_array_setItemInDummy(arrayIndex, array.unsafe_array_getItem(arrayIndex))
    parse offset, item = addedArray
        result.unsafe_array_setItemInDummy(index + offset, item)
    for :(arrayIndex Int = index) arrayIndex < oldLength; arrayIndex++
        result.unsafe_array_setItemInDummy(arrayIndex + addedLength, array.unsafe_array_getItem(arrayIndex))
    return result

#override(STD) inline
def insertPart(write array Array, index Int, addedArray Array)
    const oldLength Int = array.length~()
    const addedLength Int = addedArray.length~()
    const newLength Int = oldLength + addedLength
    inthrow
        if !index.inRange?(0, oldLength + 1)
            throw(enum::error_outOfRange, "Out of range.")
    if addedLength == 0
        return
    inthrow
        if !(oldLength == 0 || array.itemTypeNumber~() == addedArray.itemTypeNumber~())
            throw(enum::error_invalidType, "Invalid type.")
    if array.use?()
        var newArray Array = unsafe_array_createDummy(newLength, addedArray.itemTypeNumber~())
        for :(arrayIndex Int = 0) arrayIndex < index; arrayIndex++
            newArray.unsafe_array_setItemInDummy(arrayIndex, array.unsafe_array_getItem(arrayIndex))
        parse offset, item = addedArray
            newArray.unsafe_array_setItemInDummy(index + offset, item)
        for :(arrayIndex Int = index) arrayIndex < oldLength; arrayIndex++
            newArray.unsafe_array_setItemInDummy(arrayIndex + addedLength, array.unsafe_array_getItem(arrayIndex))
        array = newArray
    else
        array.unsafe_setI64(1, newLength)
        array.unsafe_realloc(newLength * 8 + 24)
        const arrayItems Int = array.unsafe_offsetI64(3)
        unsafe_memmoveI64(arrayItems.unsafe_offsetI64(index + addedLength), arrayItems.unsafe_offsetI64(index), oldLength - index)
        parse offset, item = addedArray
            array.unsafe_array_setItemInDummy(index + offset, item)

#override(STD) alwaysinline
def repeat(noread type Array, item $Any, count Int) Array
    inthrow
        if count < 0
            throw(enum::error_outOfRange, "Out of range.")
    if count == 0
        return []
    if item.nothing?()
        throw(enum::error_invalidType, "Invalid type.")
    var result Array = unsafe_array_createDummy(count, item.typeNumber~())
    for :(index Int = 0) index < count; index++
        result.unsafe_array_setItemInDummy(index, item)
    return result

#override(STD) alwaysinline
def repeatPart(part Array, count Int) Array
    inthrow
        if count < 0
            throw(enum::error_outOfRange, "Out of range.")
    const partLength Int = part.length~()
    const resultLength Int = count * partLength
    if partLength == 0 || count == 0
        return []
    var result Array = unsafe_array_createDummy(resultLength, part.itemTypeNumber~())
    for :(index Int = 0) index < resultLength; index += partLength
        parse offset, item = part
            result.unsafe_array_setItemInDummy(index + offset, item)
    return result
