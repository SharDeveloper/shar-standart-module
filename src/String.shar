module STD

//@A type that is a member of the "STD::String" group.
export primitive String

//@Members of the "STD::String" group are types whose objects contain zero or more objects (called “items”) of type “STD::Char” grouped into one object.
//@Strings can be compared for more, less, or equal.
//@If string "a" is empty, and string "b" is not empty, then string "a" is less than string "b".
//@If string "a" has zero or more items equal to the same number of items in string "b", and the next item of string "a" is less than the next item of string "b", then string "a" is less than string "b".
//@If string "a" is equal to the beginning of string "b", but at the same time string "b" contains more items than string "a", then string "a" is less than string "b".
export group String: Container, Ordered
    //@The function loads the file as a UTF-8 string.
    //@If the load was not successful, then the function returns "Nothing".
    loadFromUTF8File(noread This, String) <>This
    //@The function saves a string to a file with UTF-8 characters.
    //@If the save was successful, then the function returns "true", otherwise "false".
    saveToUTF8File(This, String) Bool

#override(STD) alwaysinline
def shar__rc_free(string String)
    const counter Int = string.unsafe_getI64(0)
    if counter > 1
        string.unsafe_setI64(0, counter - 1)
    elif counter == 1
        string.unsafe_free()

#override(STD) alwaysinline
def shar__rc_use(string String)
    const counter Int = string.unsafe_getI64(0)
    if counter != 0
        string.unsafe_setI64(0, counter + 1)

#override(STD) alwaysinline
def shar__to_const(string String)
    if string.unsafe_getI64(0) != 0
        string.unsafe_setI64(0, 0)

#override(STD) alwaysinline nothrow
def use?(string String) Bool
    return string.unsafe_getI64(0) != 1

#override(STD) alwaysinline nothrow
def constant?(string String) Bool
    return string.unsafe_getI64(0) == 0

#override(STD) inline nothrow
def clone(string String) String
    var result String = unsafe_string_createDummy(string.length~())
    unsafe_memcpyI16(result.unsafe_offsetI64(2), string.unsafe_offsetI64(2), string.length~())
    return result

#alwaysinline nothrow
def unsafe_string_createDummy(length $Any) String
    var result $Any = unsafe_malloc(length * 2 + 16)
    result.unsafe_setI64(0, 1)
    result.unsafe_setI64(1, length)
    result.unsafe_setType(String.typeNumber~())
    return result

attach String to Equal

attach String to Shar__sugar__equal
    #alwaysinline nothrow
    def shar__sugar__equal(string1, string2 String) Bool
        return string1.length~() == string2.length~() && string1.partsEqual?(0, string2, 0, string1.length~())

attach String to Shar__sugar__notEqual
    #alwaysinline nothrow
    def shar__sugar__notEqual(string1, string2 String) Bool
        return !(string1 == string2)

attach String to Ordered

attach String to Shar__sugar__less
    #alwaysinline nothrow
    def shar__sugar__less(string1, string2 String) Bool
        const length1 Int = string1.length~()
        const length2 Int = string2.length~()
        const generalLength Int = length1.min(length2)
        return unsafe_string_less(string1.unsafe_offsetI64(2), string2.unsafe_offsetI64(2), generalLength, length1, length2)

#alwaysinline nothrow
def unsafe_string_less(address1, address2, generalLength, length1, length2 $Any) Bool
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address s1 i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address s1## = inttoptr i64 %##reg##address s1 i64## to <16 x i16>*
        %##nreg##address s2 i64## = extractvalue [2 x i64] %1, 1
        %##nreg##address s2## = inttoptr i64 %##reg##address s2 i64## to <16 x i16>*
        %##nreg##length## = extractvalue [2 x i64] %2, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##address s1 1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##address s2 1## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##vector from address s1## = load <16 x i16>, <16 x i16>* %##reg##address s1 1##, align 2
        %##nreg##vector from address s2## = load <16 x i16>, <16 x i16>* %##reg##address s2 1##, align 2
        %##nreg##vector compare result## = icmp ne <16 x i16> %##reg##vector from address s1##, %##reg##vector from address s2##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        %##nreg##vectors not equal?## = icmp ne i16 %##reg##vector compare result i16##, 0
        br i1 %##reg##vectors not equal?##, label %##reg##vector not equal label##, label %##reg##vector equal label##
        ##nreg##vector equal label##:
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd address s1## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s1 1##, i64 1
        %##nreg##new simd address s2## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s2 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##vector not equal label##:
        ##llvmdeclare##llvm.cttz.i16##declare i16 @llvm.cttz.i16(i16, i1)##
        %##nreg##vector index## = call i16 @llvm.cttz.i16(i16 %##reg##vector compare result i16##, i1 1)
        %##nreg##char from vector s1## = extractelement <16 x i16> %##reg##vector from address s1##, i16 %##reg##vector index##
        %##nreg##char from vector s2## = extractelement <16 x i16> %##reg##vector from address s2##, i16 %##reg##vector index##
        %##nreg##simd result i1## = icmp ult i16 %##reg##char from vector s1##, %##reg##char from vector s2##
        %##nreg##simd result i64## = zext i1 %##reg##simd result i1## to i64
        %##nreg##simd result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##simd result i64##, 1
        ret [2 x i64] %##reg##simd result##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##vector address s1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##vector address s2## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##address s1 2## = bitcast <16 x i16>* %##reg##vector address s1## to i16*
        %##nreg##address s2 2## = bitcast <16 x i16>* %##reg##vector address s2## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##equal label##]
        %##nreg##address s1 3## = phi i16* [%##reg##address s1 2##, %##reg##scalar label##], [%##reg##new address s1 3##, %##reg##equal label##]
        %##nreg##address s2 3## = phi i16* [%##reg##address s2 2##, %##reg##scalar label##], [%##reg##new address s2 3##, %##reg##equal label##]
        %##nreg##char from address s1## = load i16, i16* %##reg##address s1 3##, align 2
        %##nreg##char from address s2## = load i16, i16* %##reg##address s2 3##, align 2
        %##nreg##chars not equal?## = icmp ne i16 %##reg##char from address s1##, %##reg##char from address s2##
        br i1 %##reg##chars not equal?##, label %##reg##not equal label##, label %##reg##equal label##
        ##nreg##equal label##:
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new address s1 3## = getelementptr i16, i16* %##reg##address s1 3##, i64 1
        %##nreg##new address s2 3## = getelementptr i16, i16* %##reg##address s2 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##not equal label##:
        %##nreg##scalar result i1## = icmp ult i16 %##reg##char from address s1##, %##reg##char from address s2##
        %##nreg##scalar result i64## = zext i1 %##reg##scalar result i1## to i64
        %##nreg##scalar result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##scalar result i64##, 1
        ret [2 x i64] %##reg##scalar result##
        ##nreg##end label##:
        %##nreg##length s1## = extractvalue [2 x i64] %3, 1
        %##nreg##length s2## = extractvalue [2 x i64] %4, 1
        %##nreg##result i1## = icmp ult i64 %##reg##length s1##, %##reg##length s2##
        %##nreg##result i64## = zext i1 %##reg##result i1## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

attach String to Shar__sugar__great
    #alwaysinline nothrow
    def shar__sugar__great(string1, string2 String) Bool
        const length1 Int = string1.length~()
        const length2 Int = string2.length~()
        const generalLength Int = length1.min(length2)
        return unsafe_string_great(string1.unsafe_offsetI64(2), string2.unsafe_offsetI64(2), generalLength, length1, length2)

#alwaysinline nothrow
def unsafe_string_great(address1, address2, generalLength, length1, length2 $Any) Bool
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address s1 i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address s1## = inttoptr i64 %##reg##address s1 i64## to <16 x i16>*
        %##nreg##address s2 i64## = extractvalue [2 x i64] %1, 1
        %##nreg##address s2## = inttoptr i64 %##reg##address s2 i64## to <16 x i16>*
        %##nreg##length## = extractvalue [2 x i64] %2, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##address s1 1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##address s2 1## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##vector from address s1## = load <16 x i16>, <16 x i16>* %##reg##address s1 1##, align 2
        %##nreg##vector from address s2## = load <16 x i16>, <16 x i16>* %##reg##address s2 1##, align 2
        %##nreg##vector compare result## = icmp ne <16 x i16> %##reg##vector from address s1##, %##reg##vector from address s2##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        %##nreg##vectors not equal?## = icmp ne i16 %##reg##vector compare result i16##, 0
        br i1 %##reg##vectors not equal?##, label %##reg##vector not equal label##, label %##reg##vector equal label##
        ##nreg##vector equal label##:
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd address s1## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s1 1##, i64 1
        %##nreg##new simd address s2## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s2 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##vector not equal label##:
        ##llvmdeclare##llvm.cttz.i16##declare i16 @llvm.cttz.i16(i16, i1)##
        %##nreg##vector index## = call i16 @llvm.cttz.i16(i16 %##reg##vector compare result i16##, i1 1)
        %##nreg##char from vector s1## = extractelement <16 x i16> %##reg##vector from address s1##, i16 %##reg##vector index##
        %##nreg##char from vector s2## = extractelement <16 x i16> %##reg##vector from address s2##, i16 %##reg##vector index##
        %##nreg##simd result i1## = icmp ugt i16 %##reg##char from vector s1##, %##reg##char from vector s2##
        %##nreg##simd result i64## = zext i1 %##reg##simd result i1## to i64
        %##nreg##simd result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##simd result i64##, 1
        ret [2 x i64] %##reg##simd result##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##vector address s1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##vector address s2## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##address s1 2## = bitcast <16 x i16>* %##reg##vector address s1## to i16*
        %##nreg##address s2 2## = bitcast <16 x i16>* %##reg##vector address s2## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##equal label##]
        %##nreg##address s1 3## = phi i16* [%##reg##address s1 2##, %##reg##scalar label##], [%##reg##new address s1 3##, %##reg##equal label##]
        %##nreg##address s2 3## = phi i16* [%##reg##address s2 2##, %##reg##scalar label##], [%##reg##new address s2 3##, %##reg##equal label##]
        %##nreg##char from address s1## = load i16, i16* %##reg##address s1 3##, align 2
        %##nreg##char from address s2## = load i16, i16* %##reg##address s2 3##, align 2
        %##nreg##chars not equal?## = icmp ne i16 %##reg##char from address s1##, %##reg##char from address s2##
        br i1 %##reg##chars not equal?##, label %##reg##not equal label##, label %##reg##equal label##
        ##nreg##equal label##:
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new address s1 3## = getelementptr i16, i16* %##reg##address s1 3##, i64 1
        %##nreg##new address s2 3## = getelementptr i16, i16* %##reg##address s2 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##not equal label##:
        %##nreg##scalar result i1## = icmp ugt i16 %##reg##char from address s1##, %##reg##char from address s2##
        %##nreg##scalar result i64## = zext i1 %##reg##scalar result i1## to i64
        %##nreg##scalar result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##scalar result i64##, 1
        ret [2 x i64] %##reg##scalar result##
        ##nreg##end label##:
        %##nreg##length s1## = extractvalue [2 x i64] %3, 1
        %##nreg##length s2## = extractvalue [2 x i64] %4, 1
        %##nreg##result i1## = icmp ugt i64 %##reg##length s1##, %##reg##length s2##
        %##nreg##result i64## = zext i1 %##reg##result i1## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

attach String to Shar__sugar__lessOrEqual
    #alwaysinline nothrow
    def shar__sugar__lessOrEqual(string1, string2 String) Bool
        const length1 Int = string1.length~()
        const length2 Int = string2.length~()
        const generalLength Int = length1.min(length2)
        return unsafe_string_lessOrEqual(string1.unsafe_offsetI64(2), string2.unsafe_offsetI64(2), generalLength, length1, length2)

#alwaysinline nothrow
def unsafe_string_lessOrEqual(address1, address2, generalLength, length1, length2 $Any) Bool
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address s1 i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address s1## = inttoptr i64 %##reg##address s1 i64## to <16 x i16>*
        %##nreg##address s2 i64## = extractvalue [2 x i64] %1, 1
        %##nreg##address s2## = inttoptr i64 %##reg##address s2 i64## to <16 x i16>*
        %##nreg##length## = extractvalue [2 x i64] %2, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##address s1 1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##address s2 1## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##vector from address s1## = load <16 x i16>, <16 x i16>* %##reg##address s1 1##, align 2
        %##nreg##vector from address s2## = load <16 x i16>, <16 x i16>* %##reg##address s2 1##, align 2
        %##nreg##vector compare result## = icmp ne <16 x i16> %##reg##vector from address s1##, %##reg##vector from address s2##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        %##nreg##vectors not equal?## = icmp ne i16 %##reg##vector compare result i16##, 0
        br i1 %##reg##vectors not equal?##, label %##reg##vector not equal label##, label %##reg##vector equal label##
        ##nreg##vector equal label##:
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd address s1## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s1 1##, i64 1
        %##nreg##new simd address s2## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s2 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##vector not equal label##:
        ##llvmdeclare##llvm.cttz.i16##declare i16 @llvm.cttz.i16(i16, i1)##
        %##nreg##vector index## = call i16 @llvm.cttz.i16(i16 %##reg##vector compare result i16##, i1 1)
        %##nreg##char from vector s1## = extractelement <16 x i16> %##reg##vector from address s1##, i16 %##reg##vector index##
        %##nreg##char from vector s2## = extractelement <16 x i16> %##reg##vector from address s2##, i16 %##reg##vector index##
        %##nreg##simd result i1## = icmp ult i16 %##reg##char from vector s1##, %##reg##char from vector s2##
        %##nreg##simd result i64## = zext i1 %##reg##simd result i1## to i64
        %##nreg##simd result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##simd result i64##, 1
        ret [2 x i64] %##reg##simd result##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##vector address s1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##vector address s2## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##address s1 2## = bitcast <16 x i16>* %##reg##vector address s1## to i16*
        %##nreg##address s2 2## = bitcast <16 x i16>* %##reg##vector address s2## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##equal label##]
        %##nreg##address s1 3## = phi i16* [%##reg##address s1 2##, %##reg##scalar label##], [%##reg##new address s1 3##, %##reg##equal label##]
        %##nreg##address s2 3## = phi i16* [%##reg##address s2 2##, %##reg##scalar label##], [%##reg##new address s2 3##, %##reg##equal label##]
        %##nreg##char from address s1## = load i16, i16* %##reg##address s1 3##, align 2
        %##nreg##char from address s2## = load i16, i16* %##reg##address s2 3##, align 2
        %##nreg##chars not equal?## = icmp ne i16 %##reg##char from address s1##, %##reg##char from address s2##
        br i1 %##reg##chars not equal?##, label %##reg##not equal label##, label %##reg##equal label##
        ##nreg##equal label##:
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new address s1 3## = getelementptr i16, i16* %##reg##address s1 3##, i64 1
        %##nreg##new address s2 3## = getelementptr i16, i16* %##reg##address s2 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##not equal label##:
        %##nreg##scalar result i1## = icmp ult i16 %##reg##char from address s1##, %##reg##char from address s2##
        %##nreg##scalar result i64## = zext i1 %##reg##scalar result i1## to i64
        %##nreg##scalar result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##scalar result i64##, 1
        ret [2 x i64] %##reg##scalar result##
        ##nreg##end label##:
        %##nreg##length s1## = extractvalue [2 x i64] %3, 1
        %##nreg##length s2## = extractvalue [2 x i64] %4, 1
        %##nreg##result i1## = icmp ule i64 %##reg##length s1##, %##reg##length s2##
        %##nreg##result i64## = zext i1 %##reg##result i1## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

attach String to Shar__sugar__greatOrEqual
    #alwaysinline nothrow
    def shar__sugar__greatOrEqual(string1, string2 String) Bool
        const length1 Int = string1.length~()
        const length2 Int = string2.length~()
        const generalLength Int = length1.min(length2)
        return unsafe_string_greatOrEqual(string1.unsafe_offsetI64(2), string2.unsafe_offsetI64(2), generalLength, length1, length2)

#alwaysinline nothrow
def unsafe_string_greatOrEqual(address1, address2, generalLength, length1, length2 $Any) Bool
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address s1 i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address s1## = inttoptr i64 %##reg##address s1 i64## to <16 x i16>*
        %##nreg##address s2 i64## = extractvalue [2 x i64] %1, 1
        %##nreg##address s2## = inttoptr i64 %##reg##address s2 i64## to <16 x i16>*
        %##nreg##length## = extractvalue [2 x i64] %2, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##address s1 1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##address s2 1## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##vector from address s1## = load <16 x i16>, <16 x i16>* %##reg##address s1 1##, align 2
        %##nreg##vector from address s2## = load <16 x i16>, <16 x i16>* %##reg##address s2 1##, align 2
        %##nreg##vector compare result## = icmp ne <16 x i16> %##reg##vector from address s1##, %##reg##vector from address s2##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        %##nreg##vectors not equal?## = icmp ne i16 %##reg##vector compare result i16##, 0
        br i1 %##reg##vectors not equal?##, label %##reg##vector not equal label##, label %##reg##vector equal label##
        ##nreg##vector equal label##:
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd address s1## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s1 1##, i64 1
        %##nreg##new simd address s2## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s2 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##vector not equal label##:
        ##llvmdeclare##llvm.cttz.i16##declare i16 @llvm.cttz.i16(i16, i1)##
        %##nreg##vector index## = call i16 @llvm.cttz.i16(i16 %##reg##vector compare result i16##, i1 1)
        %##nreg##char from vector s1## = extractelement <16 x i16> %##reg##vector from address s1##, i16 %##reg##vector index##
        %##nreg##char from vector s2## = extractelement <16 x i16> %##reg##vector from address s2##, i16 %##reg##vector index##
        %##nreg##simd result i1## = icmp ugt i16 %##reg##char from vector s1##, %##reg##char from vector s2##
        %##nreg##simd result i64## = zext i1 %##reg##simd result i1## to i64
        %##nreg##simd result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##simd result i64##, 1
        ret [2 x i64] %##reg##simd result##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##vector equal label##]
        %##nreg##vector address s1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##vector address s2## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##address s1 2## = bitcast <16 x i16>* %##reg##vector address s1## to i16*
        %##nreg##address s2 2## = bitcast <16 x i16>* %##reg##vector address s2## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##equal label##]
        %##nreg##address s1 3## = phi i16* [%##reg##address s1 2##, %##reg##scalar label##], [%##reg##new address s1 3##, %##reg##equal label##]
        %##nreg##address s2 3## = phi i16* [%##reg##address s2 2##, %##reg##scalar label##], [%##reg##new address s2 3##, %##reg##equal label##]
        %##nreg##char from address s1## = load i16, i16* %##reg##address s1 3##, align 2
        %##nreg##char from address s2## = load i16, i16* %##reg##address s2 3##, align 2
        %##nreg##chars not equal?## = icmp ne i16 %##reg##char from address s1##, %##reg##char from address s2##
        br i1 %##reg##chars not equal?##, label %##reg##not equal label##, label %##reg##equal label##
        ##nreg##equal label##:
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new address s1 3## = getelementptr i16, i16* %##reg##address s1 3##, i64 1
        %##nreg##new address s2 3## = getelementptr i16, i16* %##reg##address s2 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##not equal label##:
        %##nreg##scalar result i1## = icmp ugt i16 %##reg##char from address s1##, %##reg##char from address s2##
        %##nreg##scalar result i64## = zext i1 %##reg##scalar result i1## to i64
        %##nreg##scalar result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##scalar result i64##, 1
        ret [2 x i64] %##reg##scalar result##
        ##nreg##end label##:
        %##nreg##length s1## = extractvalue [2 x i64] %3, 1
        %##nreg##length s2## = extractvalue [2 x i64] %4, 1
        %##nreg##result i1## = icmp uge i64 %##reg##length s1##, %##reg##length s2##
        %##nreg##result i64## = zext i1 %##reg##result i1## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

attach String to Shar__sugar__getRange
    #alwaysinline
    def shar__sugar__getRange(string String, from, to Int) String
        inthrow
            if !(from >= 0 && from <= to && to <= string.length~())
                throw(enum::error_outOfRange, "Out of range.")
        var result String = ""
        const length Int = to - from
        if length != 0
            result = unsafe_string_createDummy(length)
            unsafe_memcpyI16(result.unsafe_offsetI16(8), string.unsafe_offsetI16(8 + from), length)
        return result

attach String to Shar__sugar__getItem
    #alwaysinline
    def shar__sugar__getItem(string String, index Int) Char
        inthrow
            if !index.inRange?(0, string.length~())
                throw(enum::error_outOfRange, "Out of range.")
        return string.unsafe_getI16(index + 8).unsafe_int_intToChar()

attach String to Shar__sugar__add
    #inline nothrow
    def shar__sugar__add(string, addedString String) String
        var result String = unsafe_string_createDummy(string.length~() + addedString.length~())
        unsafe_memcpyI16(result.unsafe_offsetI16(8), string.unsafe_offsetI16(8), string.length~())
        unsafe_memcpyI16(result.unsafe_offsetI16(8 + string.length~()), addedString.unsafe_offsetI16(8), addedString.length~())
        return result

attach String to Shar__sugar__addSet
    #inline nothrow
    def shar__sugar__addSet(write string, addedString String)
        if string.use?()
            string = string + addedString
        elif !addedString.empty?()
            const startStringLength Int = string.length~()
            const newLength Int = startStringLength + addedString.length~()
            string.unsafe_setI64(1, newLength)
            string.unsafe_realloc(newLength * 2 + 16)
            unsafe_memcpyI16(string.unsafe_offsetI16(8 + startStringLength), addedString.unsafe_offsetI16(8), addedString.length~())

attach String to StringWriter
    //@The function returns its argument.
    #alwaysinline nothrow
    def toString(string String) String
        return string

attach String to StringReader
    #alwaysinline
    def fromString(noread type String, string $String) String
        return string.repackTo(String)

#override(STD) alwaysinline nothrow
def print(string String)
    llvm
        %##nreg##string pointer i64## = extractvalue [2 x i64] %0, 1
        %##nreg##string pointer## = inttoptr i64 %##reg##string pointer i64## to i64*
        %##nreg##length pointer## = getelementptr i64, i64* %##reg##string pointer##, i64 1
        %##nreg##chars i64*## = getelementptr i64, i64* %##reg##string pointer##, i64 2
        %##nreg##chars## = bitcast i64* %##reg##chars i64*## to i16*
        %##nreg##length## = load i64, i64* %##reg##length pointer##, align 8
        call void @shar__print__string(i64 %##reg##length##, i16* %##reg##chars##)
        ret [2 x i64] zeroinitializer

#override(STD) alwaysinline nothrow
def println(string String)
    llvm
        %##nreg##string pointer i64## = extractvalue [2 x i64] %0, 1
        %##nreg##string pointer## = inttoptr i64 %##reg##string pointer i64## to i64*
        %##nreg##length pointer## = getelementptr i64, i64* %##reg##string pointer##, i64 1
        %##nreg##chars i64*## = getelementptr i64, i64* %##reg##string pointer##, i64 2
        %##nreg##chars## = bitcast i64* %##reg##chars i64*## to i16*
        %##nreg##length## = load i64, i64* %##reg##length pointer##, align 8
        call void @shar__println__string(i64 %##reg##length##, i16* %##reg##chars##)
        ret [2 x i64] zeroinitializer

#override(STD) nothrow
def printAsError(string String)
    llvm
        %##nreg##string pointer i64## = extractvalue [2 x i64] %0, 1
        %##nreg##string pointer## = inttoptr i64 %##reg##string pointer i64## to i64*
        %##nreg##length pointer## = getelementptr i64, i64* %##reg##string pointer##, i64 1
        %##nreg##chars i64*## = getelementptr i64, i64* %##reg##string pointer##, i64 2
        %##nreg##chars## = bitcast i64* %##reg##chars i64*## to i16*
        %##nreg##length## = load i64, i64* %##reg##length pointer##, align 8
        call void @shar__print__as__error(i64 %##reg##length##, i16* %##reg##chars##)
        ret [2 x i64] zeroinitializer

#override(STD) nothrow
def printlnAsError(string String)
    llvm
        %##nreg##string pointer i64## = extractvalue [2 x i64] %0, 1
        %##nreg##string pointer## = inttoptr i64 %##reg##string pointer i64## to i64*
        %##nreg##length pointer## = getelementptr i64, i64* %##reg##string pointer##, i64 1
        %##nreg##chars i64*## = getelementptr i64, i64* %##reg##string pointer##, i64 2
        %##nreg##chars## = bitcast i64* %##reg##chars i64*## to i16*
        %##nreg##length## = load i64, i64* %##reg##length pointer##, align 8
        call void @shar__println__as__error(i64 %##reg##length##, i16* %##reg##chars##)
        ret [2 x i64] zeroinitializer

attach String to Hashable
    #alwaysinline nothrow
    def getHash(string String) Int
        var result Int = string.length~()
        result += result << 10
        result ^= result >> 6
        for :(index Int = 0) index < string.length~(); index++
            result += string.unsafe_getI16(index + 8)
            result += result << 10
            result ^= result >> 6
        result += result << 3
        result ^= result >> 11
        result += result << 15
        return result

    #alwaysinline nothrow
    def getRandomizedHash(string String) Int
        const randomNumber Int = const::staticRandomNumber
        const rightShifts Int = (randomNumber & 0xf) + 32
        const leftShifts Int = ((randomNumber & 0xf0) >> 4) + 32
        var result Int = randomNumber + string.length~()
        result += result << 10
        result ^= result >> 6
        for :(index Int = 0) index < string.length~(); index++
            result = (result >> rightShifts) + (result << leftShifts) + (result & 0xffffffff)
            result += string.unsafe_getI16(index + 8)
            result += result << 10
            result ^= result >> 6
        result += result << 3
        result ^= result >> 11
        result += result << 15
        return result

attach String to Long
    #alwaysinline nothrow
    def length~(string String) Int
        return string.unsafe_getI64(1)

attach String to Empty
    #alwaysinline nothrow
    def createEmpty(noread type String) String
        return ""

attach String to Put
    #alwaysinline
    def put(write string String, index Int, newChar Char) Char
        const oldChar Char = string[index]
        if string.use?()
            string = string.clone()
        string.unsafe_setI16(index + 8, newChar)
        return oldChar

attach String to Iterable
    #alwaysinline nothrow
    def parse__init(string String) Int
        return 0

    #alwaysinline nothrow
    def parse__predicate(string String, index Int) Bool
        return index != string.length~()

    #alwaysinline unsafewrite nothrow
    def parse__next(string String, write index Int)
        index++

    #alwaysinline nothrow
    def parse__get__key(string String, index Int) Int
        return index

    #alwaysinline nothrow
    def parse__get__item(string String, index Int) Char
        return string[index]

attach String to Container
    #alwaysinline nothrow
    def addItem(write string String, newChar Char)
        if string.use?()
            string = string.addItem$(newChar)
        else
            const newLength Int = string.length~() + 1
            string.unsafe_setI64(1, newLength)
            string.unsafe_realloc(newLength * 2 + 16)
            string.unsafe_setI16(newLength + 7, newChar)

    #alwaysinline nothrow
    def addItem$(string String, newChar Char) String
        var newString String = unsafe_string_createDummy(string.length~() + 1)
        unsafe_memcpyI16(newString.unsafe_offsetI64(2), string.unsafe_offsetI64(2), string.length~())
        newString.unsafe_setI16(string.length~() + 8, newChar)
        return newString

attach String to String
    #alwaysinline
    def loadFromUTF8File(noread type, fileName String) <>String
        const utf8String <>Bytes = loadFile(fileName)
        if utf8String.nothing?()
            return nothing
        const utf8StringLength Int = utf8String.length~()
        var positionInUTF8String Int = 0
        var result String = ""
        for positionInUTF8String < utf8StringLength
            var newChar Int = utf8String[positionInUTF8String]
            positionInUTF8String++
            if newChar > 127
                if (newChar & 224) == 192
                    inthrow
                        if positionInUTF8String == utf8StringLength
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    var charPart Int = utf8String[positionInUTF8String]
                    positionInUTF8String++
                    inthrow
                        if (charPart & 192) != 128
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    newChar ^= 192
                    newChar <<= 6
                    newChar |= charPart ^ 128
                elif (newChar & 240) == 224
                    inthrow
                        if positionInUTF8String == utf8StringLength
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    var charPart Int = utf8String[positionInUTF8String]
                    positionInUTF8String++
                    inthrow
                        if (charPart & 192) != 128
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    newChar ^= 224
                    newChar <<= 6
                    newChar |= charPart ^ 128
                    inthrow
                        if positionInUTF8String == utf8StringLength
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    charPart = utf8String[positionInUTF8String]
                    positionInUTF8String++
                    inthrow
                        if (charPart & 192) != 128
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    newChar <<= 6
                    newChar |= charPart ^ 128
                else
                    throw(enum::error_invalidCharacter, "Invalid character.")
            result.addItem(newChar.unsafe_int_intToChar())
        return result

    #alwaysinline nothrow
    def saveToUTF8File(string, fileName String) Bool
        var utf8String Bytes = Bytes.createEmpty()
        parse _, char = string
            const charAsInt Int = char.charToInt()
            if charAsInt < 0x80
                utf8String.addItem(charAsInt)
            elif charAsInt > 0x7f && charAsInt < 0x800
                utf8String.addItem((charAsInt >> 6) | 192)
                utf8String.addItem((charAsInt & 63) | 128)
            elif charAsInt > 0x7ff
                utf8String.addItem((charAsInt >> 12) | 192)
                utf8String.addItem(((charAsInt >> 6) & 63) | 128)
                utf8String.addItem((charAsInt & 63) | 128)
        return saveToFile(fileName, utf8String)

#override(STD) alwaysinline
def copy(write destination String, destinationPosition Int, source String, sourcePosition, length Int)
    const destinationLength Int = destination.length~()
    const sourceLength Int = source.length~()
    inthrow
        if {
            !(
                destinationPosition >= 0 && destinationPosition <= destinationLength &&
                sourcePosition >= 0 && sourcePosition <= sourceLength &&
                length >= 0 && length <= (destinationLength - destinationPosition).min(sourceLength - sourcePosition)
            )
        }
            throw(enum::error_outOfRange, "Out of range.")
    if destination.use?()
        var newString String = unsafe_string_createDummy(destinationLength)
        unsafe_memcpyI16(newString.unsafe_offsetI64(2), destination.unsafe_offsetI64(2), destinationPosition)
        unsafe_memcpyI16(destination.unsafe_offsetI16(8 + destinationPosition), source.unsafe_offsetI16(8 + sourcePosition), length)
        const lastPartStartIndex Int = destinationPosition + length
        unsafe_memcpyI16(newString.unsafe_offsetI16(8 + lastPartStartIndex), destination.unsafe_offsetI16(8 + lastPartStartIndex), destination.length~() - lastPartStartIndex)
        destination = newString
    else
        unsafe_memcpyI16(destination.unsafe_offsetI16(8 + destinationPosition), source.unsafe_offsetI16(8 + sourcePosition), length)


attach String to BinarySerializable
    #alwaysinline nothrow
    def serialize(string String, write bytes Bytes)
        var utf8String Bytes = Bytes.createEmpty()
        parse _, char = string
            const charAsInt Int = char.charToInt()
            if charAsInt < 0x80
                utf8String.addItem(charAsInt)
            elif charAsInt > 0x7f && charAsInt < 0x800
                utf8String.addItem((charAsInt >> 6) | 192)
                utf8String.addItem((charAsInt & 63) | 128)
            elif charAsInt > 0x7ff
                utf8String.addItem((charAsInt >> 12) | 192)
                utf8String.addItem(((charAsInt >> 6) & 63) | 128)
                utf8String.addItem((charAsInt & 63) | 128)
        serialize(utf8String, bytes)

    #alwaysinline
    def deserialize(noread type String, bytes Bytes, write position Int) String
        const utf8String Bytes = Bytes.deserialize(bytes, position)
        const utf8StringLength Int = utf8String.length~()
        var positionInUTF8String Int = 0
        var result String = ""
        for positionInUTF8String < utf8StringLength
            var newChar Int = utf8String[positionInUTF8String]
            positionInUTF8String++
            if newChar > 127
                if (newChar & 224) == 192
                    inthrow
                        if positionInUTF8String == utf8StringLength
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    var charPart Int = utf8String[positionInUTF8String]
                    positionInUTF8String++
                    inthrow
                        if (charPart & 192) != 128
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    newChar ^= 192
                    newChar <<= 6
                    newChar |= charPart ^ 128
                elif (newChar & 240) == 224
                    inthrow
                        if positionInUTF8String == utf8StringLength
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    var charPart Int = utf8String[positionInUTF8String]
                    positionInUTF8String++
                    inthrow
                        if (charPart & 192) != 128
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    newChar ^= 224
                    newChar <<= 6
                    newChar |= charPart ^ 128
                    inthrow
                        if positionInUTF8String == utf8StringLength
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    charPart = utf8String[positionInUTF8String]
                    positionInUTF8String++
                    inthrow
                        if (charPart & 192) != 128
                            throw(enum::error_invalidCharacter, "Invalid character.")
                    newChar <<= 6
                    newChar |= charPart ^ 128
                else
                    throw(enum::error_invalidCharacter, "Invalid character.")
            result.addItem(newChar.unsafe_int_intToChar())
        return result

#override(STD) alwaysinline
def swap(write string String, position1, position2 Int)
    inthrow
        if !(position1.inRange?(0, string.length~()) && position2.inRange?(0, string.length~()))
            throw(enum::error_outOfRange, "Out of range.")
    if string.use?()
        string = string.clone()
    const items Int = string.unsafe_offsetI64(2)
    const tmpItem Int = items.unsafe_getI16(position1)
    items.unsafe_setI16(position1, items.unsafe_getI16(position2))
    items.unsafe_setI16(position2, tmpItem)

#override(STD) alwaysinline
def setItem(write string String, index Int, newChar Char)
    string.put(index, newChar)

#override(STD) alwaysinline
def countFromAtoB(string String, char Char, a, b Int) Int
    inthrow
        if !(a >= 0 && a <= b && b <= string.length~())
            throw(enum::error_outOfRange, "Out of range.")
    return unsafe_string_countFromAtoB(string.unsafe_offsetI16(a + 8), char, b - a)

#alwaysinline nothrow
def unsafe_string_countFromAtoB(address, char, length $Any) Int
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address## = inttoptr i64 %##reg##address i64## to <16 x i16>*
        %##nreg##char 64## = extractvalue [2 x i64] %1, 1
        %##nreg##char## = trunc i64 %##reg##char 64## to i16
        %##nreg##length## = extractvalue [2 x i64] %2, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd label##, label %##reg##scalar label##
        ##nreg##simd label##:
        %##nreg##<1 x char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##char##, i32 0
        %##nreg##<16 x char>## = shufflevector <1 x i16> %##reg##<1 x char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        br label %##reg##simd loop##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##length##, %##reg##simd label##], [%##reg##new remain chars 1##, %##reg##simd loop##]
        %##nreg##result 1## = phi i64 [0, %##reg##simd label##], [%##reg##new result 1##, %##reg##simd loop##]
        %##nreg##address 1## = phi <16 x i16>* [%##reg##address##, %##reg##simd label##], [%##reg##new simd address##, %##reg##simd loop##]
        %##nreg##vector from address## = load <16 x i16>, <16 x i16>* %##reg##address 1##, align 2
        %##nreg##vector compare result## = icmp eq <16 x i16> %##reg##vector from address##, %##reg##<16 x char>##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        ##llvmdeclare##llvm.ctpop.i16##declare i16 @llvm.ctpop.i16(i16)##
        %##nreg##count of chars in vector## = call i16 @llvm.ctpop.i16(i16 %##reg##vector compare result i16##)
        %##nreg##count of chars in vector i64## = zext i16 %##reg##count of chars in vector## to i64
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new result 1## = add i64 %##reg##result 1##, %##reg##count of chars in vector i64##
        %##nreg##new simd address## = getelementptr <16 x i16>, <16 x i16>* %##reg##address 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##simd loop##]
        %##nreg##result 2## = phi i64 [0, %##reg##start##], [%##reg##new result 1##, %##reg##simd loop##]
        %##nreg##vector address## = phi <16 x i16>* [%##reg##address##, %##reg##start##], [%##reg##new simd address##, %##reg##simd loop##]
        %##nreg##address 2## = bitcast <16 x i16>* %##reg##vector address## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##scalar loop##]
        %##nreg##result 3## = phi i64 [%##reg##result 2##, %##reg##scalar label##], [%##reg##new result 3##, %##reg##scalar loop##]
        %##nreg##address 3## = phi i16* [%##reg##address 2##, %##reg##scalar label##], [%##reg##new address 3##, %##reg##scalar loop##]
        %##nreg##char from address## = load i16, i16* %##reg##address 3##, align 2
        %##nreg##found char?## = icmp eq i16 %##reg##char from address##, %##reg##char##
        %##nreg##found char? i64## = zext i1 %##reg##found char?## to i64
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new result 3## = add i64 %##reg##result 3##, %##reg##found char? i64##
        %##nreg##new address 3## = getelementptr i16, i16* %##reg##address 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##end label##:
        %##nreg##result 4## = phi i64 [%##reg##result 2##, %##reg##scalar label##], [%##reg##new result 3##, %##reg##scalar loop##]
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##result 4##, 1
        ret [2 x i64] %##reg##result##

#override(STD) inline
def countPartFromAtoB(string, part String, a, b Int) Int
    const partLength Int = part.length~()
    const stringLength Int = string.length~()
    inthrow
        if !(a >= 0 && a <= b && b <= stringLength)
            throw(enum::error_outOfRange, "Out of range.")
        if partLength == 0
            throw(enum::error_nothingToLook, "There is nothing to count.")
    var result Int = 0
    const edge Int = b - partLength + 1
    if edge > 0
        const firstChar Char = part.unsafe_getI16(8).unsafe_int_intToChar()
        for :(index Int = a) index < edge
            const indexOfFirstChar <>Int = string.lookFromAtoB(firstChar, index, edge)
            if indexOfFirstChar.nothing?()
                end index
            if string.partsEqual?(indexOfFirstChar, part, 0, partLength)
                result++
                index = indexOfFirstChar + partLength
            else
                index = indexOfFirstChar + 1
    return result

#override(STD) alwaysinline nothrow
def partsEqual?(string1 String, from1 Int, string2 String, from2, length Int) Bool
    const string1Length Int = string1.length~()
    const string2Length Int = string2.length~()
    return {
        from1 >= 0 && from1 <= string1Length &&
        from2 >= 0 && from2 <= string2Length &&
        length >= 0 && length <= (string1Length - from1).min(string2Length - from2) &&
        unsafe_string_partsEqual?(string1.unsafe_offsetI16(from1 + 8), string2.unsafe_offsetI16(from2 + 8), length)
    }

#alwaysinline nothrow
def unsafe_string_partsEqual?(address1, address2, length $Any) Bool
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address s1 i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address s1## = inttoptr i64 %##reg##address s1 i64## to <16 x i16>*
        %##nreg##address s2 i64## = extractvalue [2 x i64] %1, 1
        %##nreg##address s2## = inttoptr i64 %##reg##address s2 i64## to <16 x i16>*
        %##nreg##length## = extractvalue [2 x i64] %2, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##simd loop##:
        %##nreg##remain items 1## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain items 1##, %##reg##vector equal label##]
        %##nreg##address s1 1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##address s2 1## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##vector from address s1## = load <16 x i16>, <16 x i16>* %##reg##address s1 1##, align 2
        %##nreg##vector from address s2## = load <16 x i16>, <16 x i16>* %##reg##address s2 1##, align 2
        %##nreg##vector compare result## = icmp eq <16 x i16> %##reg##vector from address s1##, %##reg##vector from address s2##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        %##nreg##vectors not equal?## = icmp ne i16 %##reg##vector compare result i16##, -1
        br i1 %##reg##vectors not equal?##, label %##reg##vector not equal label##, label %##reg##vector equal label##
        ##nreg##vector not equal label##:
        ret [2 x i64] [i64 ##tnum##STD::Bool##, i64 0]
        ##nreg##vector equal label##:
        %##nreg##new remain items 1## = sub i64 %##reg##remain items 1##, 16
        %##nreg##new simd address s1## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s1 1##, i64 1
        %##nreg##new simd address s2## = getelementptr <16 x i16>, <16 x i16>* %##reg##address s2 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain items 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##scalar label##:
        %##nreg##remain items 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain items 1##, %##reg##vector equal label##]
        %##nreg##vector address s1## = phi <16 x i16>* [%##reg##address s1##, %##reg##start##], [%##reg##new simd address s1##, %##reg##vector equal label##]
        %##nreg##vector address s2## = phi <16 x i16>* [%##reg##address s2##, %##reg##start##], [%##reg##new simd address s2##, %##reg##vector equal label##]
        %##nreg##address s1 2## = bitcast <16 x i16>* %##reg##vector address s1## to i16*
        %##nreg##address s2 2## = bitcast <16 x i16>* %##reg##vector address s2## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain items 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain items 3## = phi i64 [%##reg##remain items 2##, %##reg##scalar label##], [%##reg##new remain items 3##, %##reg##scalar loop##]
        %##nreg##address s1 3## = phi i16* [%##reg##address s1 2##, %##reg##scalar label##], [%##reg##new address s1 3##, %##reg##scalar loop##]
        %##nreg##address s2 3## = phi i16* [%##reg##address s2 2##, %##reg##scalar label##], [%##reg##new address s2 3##, %##reg##scalar loop##]
        %##nreg##result i1## = phi i1 [1, %##reg##scalar label##], [%##reg##new result i1##, %##reg##scalar loop##]
        %##nreg##item from address s1## = load i16, i16* %##reg##address s1 3##, align 2
        %##nreg##item from address s2## = load i16, i16* %##reg##address s2 3##, align 2
        %##nreg##item equal?## = icmp eq i16 %##reg##item from address s1##, %##reg##item from address s2##
        %##nreg##new result i1## = and i1 %##reg##result i1##, %##reg##item equal?##
        %##nreg##new remain items 3## = sub i64 %##reg##remain items 3##, 1
        %##nreg##new address s1 3## = getelementptr i16, i16* %##reg##address s1 3##, i64 1
        %##nreg##new address s2 3## = getelementptr i16, i16* %##reg##address s2 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain items 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##end label##:
        %##nreg##end result i1## = phi i1 [1, %##reg##scalar label##], [%##reg##new result i1##, %##reg##scalar loop##]
        %##nreg##end result i64## = zext i1 %##reg##end result i1## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##end result i64##, 1
        ret [2 x i64] %##reg##result##

#override(STD) alwaysinline
def lookNFromAtoB(string String, char Char, n, a, b Int) <>Int
    inthrow
        if !(n > 0 && a >= 0 && a <= b && b <= string.length~())
            throw(enum::error_outOfRange, "Out of range.")
    return unsafe_string_lookNFromAtoB(string.unsafe_offsetI16(a + 8), char, n, a, b)

#alwaysinline nothrow
def unsafe_string_lookNFromAtoB(address, char, n, a, b $Any) <>Int
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address## = inttoptr i64 %##reg##address i64## to <16 x i16>*
        %##nreg##char 64## = extractvalue [2 x i64] %1, 1
        %##nreg##char## = trunc i64 %##reg##char 64## to i16
        %##nreg##n## = extractvalue [2 x i64] %2, 1
        %##nreg##a## = extractvalue [2 x i64] %3, 1
        %##nreg##b## = extractvalue [2 x i64] %4, 1
        %##nreg##range size## = sub i64 %##reg##b##, %##reg##a##
        %##nreg##use simd## = icmp uge i64 %##reg##range size##, 16
        br i1 %##reg##use simd##, label %##reg##simd label##, label %##reg##scalar label##
        ##nreg##simd label##:
        %##nreg##<1 x char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##char##, i32 0
        %##nreg##<16 x char>## = shufflevector <1 x i16> %##reg##<1 x char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        br label %##reg##simd loop##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##range size##, %##reg##simd label##], [%##reg##new remain chars 1##, %##reg##continue simd search##]
        %##nreg##n 1## = phi i64 [%##reg##n##, %##reg##simd label##], [%##reg##n in simd look##, %##reg##continue simd search##]
        %##nreg##address 1## = phi <16 x i16>* [%##reg##address##, %##reg##simd label##], [%##reg##new simd address##, %##reg##continue simd search##]
        %##nreg##vector from address## = load <16 x i16>, <16 x i16>* %##reg##address 1##, align 2
        %##nreg##vector compare result## = icmp eq <16 x i16> %##reg##vector from address##, %##reg##<16 x char>##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        br label %##reg##look loop##
        ##nreg##look loop##:
        %##nreg##chars as bits## = phi i16 [%##reg##vector compare result i16##, %##reg##simd loop##], [%##reg##new chars as bits##, %##reg##look label##]
        %##nreg##offset## = phi i64 [0, %##reg##simd loop##], [%##reg##new offset##, %##reg##look label##]
        %##nreg##n in simd look## = phi i64 [%##reg##n 1##, %##reg##simd loop##], [%##reg##new n in simd look##, %##reg##look label##]
        %##nreg##found chars?## = icmp ne i16 %##reg##chars as bits##, 0
        br i1 %##reg##found chars?##, label %##reg##look label##, label %##reg##continue simd search##
        ##nreg##look label##:
        %##nreg##char as bit## = and i16 %##reg##chars as bits##, 1
        %##nreg##char as bit i64## = zext i16 %##reg##char as bit## to i64
        %##nreg##new n in simd look## = sub i64 %##reg##n in simd look##, %##reg##char as bit i64##
        %##nreg##new chars as bits## = lshr i16 %##reg##chars as bits##, 1
        %##nreg##new offset## = add i64 %##reg##offset##, 1
        %##nreg##simd found char?## = icmp eq i64 %##reg##new n in simd look##, 0
        br i1 %##reg##simd found char?##, label %##reg##simd found label##, label %##reg##look loop##
        ##nreg##simd found label##:
        %##nreg##simd offset## = sub i64 %##reg##range size##, %##reg##remain chars 1##
        %##nreg##start index## = add i64 %##reg##a##, %##reg##simd offset##
        %##nreg##full simd index## = add i64 %##reg##start index##, %##reg##offset##
        %##nreg##simd result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##full simd index##, 1
        ret [2 x i64] %##reg##simd result##
        ##nreg##continue simd search##:
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd address## = getelementptr <16 x i16>, <16 x i16>* %##reg##address 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##range size##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##continue simd search##]
        %##nreg##n 2## = phi i64 [%##reg##n##, %##reg##start##], [%##reg##n in simd look##, %##reg##continue simd search##]
        %##nreg##vector address## = phi <16 x i16>* [%##reg##address##, %##reg##start##], [%##reg##new simd address##, %##reg##continue simd search##]
        %##nreg##address 2## = bitcast <16 x i16>* %##reg##vector address## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##continue scalar search##]
        %##nreg##n 3## = phi i64 [%##reg##n 2##, %##reg##scalar label##], [%##reg##new n 3##, %##reg##continue scalar search##]
        %##nreg##address 3## = phi i16* [%##reg##address 2##, %##reg##scalar label##], [%##reg##new address 3##, %##reg##continue scalar search##]
        %##nreg##char from address## = load i16, i16* %##reg##address 3##, align 2
        %##nreg##found char?## = icmp eq i16 %##reg##char from address##, %##reg##char##
        %##nreg##found char? i64## = zext i1 %##reg##found char?## to i64
        %##nreg##new n 3## = sub i64 %##reg##n 3##, %##reg##found char? i64##
        %##nreg##final found char## = icmp eq i64 %##reg##new n 3##, 0
        br i1 %##reg##final found char##, label %##reg##final found char label##, label %##reg##continue scalar search##
        ##nreg##continue scalar search##:
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new address 3## = getelementptr i16, i16* %##reg##address 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##final found char label##:
        %##nreg##scalar offset## = sub i64 %##reg##range size##, %##reg##remain chars 3##
        %##nreg##full scalar index## = add i64 %##reg##scalar offset##, %##reg##a##
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##full scalar index##, 1
        ret [2 x i64] %##reg##result##
        ##nreg##end label##:
        ret [2 x i64] zeroinitializer

#override(STD) inline
def lookNPartFromAtoB(string, part String, n, a, b Int) <>Int
    const partLength Int = part.length~()
    const stringLength Int = string.length~()
    inthrow
        if !(n > 0 && a >= 0 && a <= b && b <= stringLength)
            throw(enum::error_outOfRange, "Out of range.")
        if partLength == 0
            throw(enum::error_nothingToLook, "There is nothing to look for.")
    const edge Int = b - partLength + 1
    if edge > 0
        var mutN Int = n
        const firstChar Char = part.unsafe_getI16(8).unsafe_int_intToChar()
        for :(index Int = a) index < edge
            const indexOfFirstChar <>Int = string.lookFromAtoB(firstChar, index, edge)
            if indexOfFirstChar.nothing?()
                end index
            if string.partsEqual?(indexOfFirstChar, part, 0, partLength)
                if mutN == 1
                    return indexOfFirstChar
                mutN--
                index = indexOfFirstChar + partLength
            else
                index = indexOfFirstChar + 1
    return nothing

#override(STD) alwaysinline
def lookAllFromAtoB(string String, char Char, a, b Int) Array
    inthrow
        if !(a >= 0 && a <= b && b <= string.length~())
            throw(enum::error_outOfRange, "Out of range.")
    var result Array = [].clone()
    unsafe_string_lookAllFromAtoB(string.unsafe_offsetI16(a + 8), char, a, b, result)
    return result

#alwaysinline nothrow unsafewrite
def unsafe_string_lookAllFromAtoB(address, char, a, b, write result $Any)
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address## = inttoptr i64 %##reg##address i64## to <16 x i16>*
        %##nreg##char 64## = extractvalue [2 x i64] %1, 1
        %##nreg##char## = trunc i64 %##reg##char 64## to i16
        %##nreg##a## = extractvalue [2 x i64] %2, 1
        %##nreg##b## = extractvalue [2 x i64] %3, 1
        %##nreg##range size## = sub i64 %##reg##b##, %##reg##a##
        %##nreg##use simd## = icmp uge i64 %##reg##range size##, 16
        br i1 %##reg##use simd##, label %##reg##simd label##, label %##reg##scalar label##
        ##nreg##simd label##:
        %##nreg##<1 x char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##char##, i32 0
        %##nreg##<16 x char>## = shufflevector <1 x i16> %##reg##<1 x char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        br label %##reg##simd loop##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##range size##, %##reg##simd label##], [%##reg##new remain chars 1##, %##reg##simd continue search##]
        %##nreg##address 1## = phi <16 x i16>* [%##reg##address##, %##reg##simd label##], [%##reg##new simd address##, %##reg##simd continue search##]
        %##nreg##vector from address## = load <16 x i16>, <16 x i16>* %##reg##address 1##, align 2
        %##nreg##vector compare result## = icmp eq <16 x i16> %##reg##vector from address##, %##reg##<16 x char>##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        %##nreg##have chars?## = icmp ne i16 %##reg##vector compare result i16##, 0
        br i1 %##reg##have chars?##, label %##reg##simd add indexes##, label %##reg##simd continue search##
        ##nreg##simd add indexes##:
        %##nreg##simd offset## = sub i64 %##reg##range size##, %##reg##remain chars 1##
        %##nreg##start index## = add i64 %##reg##a##, %##reg##simd offset##
        %##nreg##start index arg## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##start index##, 1
        ##llvmdeclare##llvm.ctpop.i16##declare i16 @llvm.ctpop.i16(i16)##
        %##nreg##count of chars in vector## = call i16 @llvm.ctpop.i16(i16 %##reg##vector compare result i16##)
        %##nreg##count of chars in vector i64## = zext i16 %##reg##count of chars in vector## to i64
        %##nreg##count of chars in vector arg## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##count of chars in vector i64##, 1
        %##nreg##vector compare result i64## = zext i16 %##reg##vector compare result i16## to i64
        %##nreg##vector compare result arg## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##vector compare result i64##, 1
        %##nreg##unneeded 1## = call [2 x i64] ##ancntfunc##STD::unsafe_string_lookAllFromAtoB_addIndexes_SIMD##([2 x i64] %##reg##start index arg##, [2 x i64] %##reg##count of chars in vector arg##, [2 x i64] %##reg##vector compare result arg##, [2 x i64]* %4)
        br label %##reg##simd continue search##
        ##nreg##simd continue search##:
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd address## = getelementptr <16 x i16>, <16 x i16>* %##reg##address 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##range size##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##simd continue search##]
        %##nreg##vector address## = phi <16 x i16>* [%##reg##address##, %##reg##start##], [%##reg##new simd address##, %##reg##simd continue search##]
        %##nreg##address 2## = bitcast <16 x i16>* %##reg##vector address## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##scalar continue search##]
        %##nreg##address 3## = phi i16* [%##reg##address 2##, %##reg##scalar label##], [%##reg##new address 3##, %##reg##scalar continue search##]
        %##nreg##char from address## = load i16, i16* %##reg##address 3##, align 2
        %##nreg##have char?## = icmp eq i16 %##reg##char from address##, %##reg##char##
        br i1 %##reg##have char?##, label %##reg##scalar add index##, label %##reg##scalar continue search##
        ##nreg##scalar add index##:
        %##nreg##offset## = sub i64 %##reg##range size##, %##reg##remain chars 3##
        %##nreg##scalar start index## = add i64 %##reg##a##, %##reg##offset##
        %##nreg##scalar start index arg## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##scalar start index##, 1
        %##nreg##unneeded 2## = call [2 x i64] ##ancntfunc##STD::unsafe_string_lookAllFromAtoB_addIndex_scalar##([2 x i64] %##reg##scalar start index arg##, [2 x i64]* %4)
        br label %##reg##scalar continue search##
        ##nreg##scalar continue search##:
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new address 3## = getelementptr i16, i16* %##reg##address 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##end label##:
        %##nreg##result pointer of pointer## = getelementptr [2 x i64], [2 x i64]* %4, i64 0, i64 1
        %##nreg##result pointer i64## = load i64, i64* %##reg##result pointer of pointer##, align 8
        %##nreg##result pointer## = inttoptr i64 %##reg##result pointer i64## to i64*
        %##nreg##result length pointer## = getelementptr i64, i64* %##reg##result pointer##, i64 1
        %##nreg##result type pointer## = getelementptr i64, i64* %##reg##result pointer##, i64 2
        %##nreg##result length## = load i64, i64* %##reg##result length pointer##, align 8
        %##nreg##length == 0## = icmp eq i64 %##reg##result length##, 0
        %##nreg##result new item type## = select i1 %##reg##length == 0##, i64 ##tnum##STD::Nothing##, i64 ##tnum##STD::Int##
        store i64 %##reg##result new item type##, i64* %##reg##result type pointer##, align 8
        ret [2 x i64] zeroinitializer

#alwaysinline nothrow
def unsafe_string_lookAllFromAtoB_addIndexes_SIMD(startIndex, countOfNewIndexes, charsAsBits Int, write indexes Array)
    const oldLength Int = indexes.length~()
    const newLength Int = oldLength + countOfNewIndexes
    indexes.unsafe_setI64(1, newLength)
    indexes.unsafe_realloc(newLength * 8 + 24)
    const newIndexes Int = indexes.unsafe_offsetI64(3 + oldLength)
    var mutCharsAsBits Int = charsAsBits
    var index Int = startIndex
    var offset Int = 0
    for :(loop)
        if (mutCharsAsBits & 1) == 1
            newIndexes.unsafe_setI64(offset, index)
            offset++
        mutCharsAsBits >>= 1
        if mutCharsAsBits == 0
            end loop
        index++

#alwaysinline nothrow
def unsafe_string_lookAllFromAtoB_addIndex_scalar(index Int, write indexes Array)
    const oldLength Int = indexes.length~()
    const newLength Int = oldLength + 1
    indexes.unsafe_setI64(1, newLength)
    indexes.unsafe_realloc(newLength * 8 + 24)
    indexes.unsafe_setI64(oldLength + 3, index)

#override(STD) alwaysinline
def lookAllPartsFromAtoB(string, part String, a, b Int) Array
    const partLength Int = part.length~()
    const stringLength Int = string.length~()
    inthrow
        if !(a >= 0 && a <= b && b <= stringLength)
            throw(enum::error_outOfRange, "Out of range.")
        if partLength == 0
            throw(enum::error_nothingToLook, "There is nothing to count.")
    var result Array = []
    const edge Int = b - partLength + 1
    if edge > 0
        const firstChar Char = part.unsafe_getI16(8).unsafe_int_intToChar()
        for :(index Int = a) index < edge
            const indexOfFirstChar <>Int = string.lookFromAtoB(firstChar, index, edge)
            if indexOfFirstChar.nothing?()
                end index
            if string.partsEqual?(indexOfFirstChar, part, 0, partLength)
                result.addItem(indexOfFirstChar)
                index = indexOfFirstChar + partLength
            else
                index = indexOfFirstChar + 1
    return result


#override(STD) alwaysinline
def lookBackNFromAtoB(string String, char Char, n, a, b Int) <>Int
    inthrow
        if !(n > 0 && a >= 0 && a <= b && b <= string.length~())
            throw(enum::error_outOfRange, "Out of range.")
    return unsafe_string_lookBackNFromAtoB(string.unsafe_offsetI16(b + 8), char, n, a, b)

#alwaysinline nothrow
def unsafe_string_lookBackNFromAtoB(address, char, n, a, b $Any) <>Int
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address## = inttoptr i64 %##reg##address i64## to <16 x i16>*
        %##nreg##char 64## = extractvalue [2 x i64] %1, 1
        %##nreg##char## = trunc i64 %##reg##char 64## to i16
        %##nreg##n## = extractvalue [2 x i64] %2, 1
        %##nreg##a## = extractvalue [2 x i64] %3, 1
        %##nreg##b## = extractvalue [2 x i64] %4, 1
        %##nreg##range size## = sub i64 %##reg##b##, %##reg##a##
        %##nreg##use simd## = icmp uge i64 %##reg##range size##, 16
        br i1 %##reg##use simd##, label %##reg##simd label##, label %##reg##scalar label##
        ##nreg##simd label##:
        %##nreg##<1 x char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##char##, i32 0
        %##nreg##<16 x char>## = shufflevector <1 x i16> %##reg##<1 x char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        br label %##reg##simd loop##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##range size##, %##reg##simd label##], [%##reg##new remain chars 1##, %##reg##continue simd search##]
        %##nreg##n 1## = phi i64 [%##reg##n##, %##reg##simd label##], [%##reg##n in simd look##, %##reg##continue simd search##]
        %##nreg##after address 1## = phi <16 x i16>* [%##reg##address##, %##reg##simd label##], [%##reg##address 1##, %##reg##continue simd search##]
        %##nreg##address 1## = getelementptr <16 x i16>, <16 x i16>* %##reg##after address 1##, i64 -1
        %##nreg##vector from address## = load <16 x i16>, <16 x i16>* %##reg##address 1##, align 2
        %##nreg##vector compare result## = icmp eq <16 x i16> %##reg##vector from address##, %##reg##<16 x char>##
        %##nreg##vector compare result i16## = bitcast <16 x i1> %##reg##vector compare result## to i16
        br label %##reg##look loop##
        ##nreg##look loop##:
        %##nreg##chars as bits## = phi i16 [%##reg##vector compare result i16##, %##reg##simd loop##], [%##reg##new chars as bits##, %##reg##look label##]
        %##nreg##offset## = phi i64 [1, %##reg##simd loop##], [%##reg##new offset##, %##reg##look label##]
        %##nreg##n in simd look## = phi i64 [%##reg##n 1##, %##reg##simd loop##], [%##reg##new n in simd look##, %##reg##look label##]
        %##nreg##found chars?## = icmp ne i16 %##reg##chars as bits##, 0
        br i1 %##reg##found chars?##, label %##reg##look label##, label %##reg##continue simd search##
        ##nreg##look label##:
        %##nreg##char as bit << 15## = and i16 %##reg##chars as bits##, 32768
        %##nreg##char as bit## = lshr i16 %##reg##char as bit << 15##, 15
        %##nreg##char as bit i64## = zext i16 %##reg##char as bit## to i64
        %##nreg##new n in simd look## = sub i64 %##reg##n in simd look##, %##reg##char as bit i64##
        %##nreg##new chars as bits## = shl i16 %##reg##chars as bits##, 1
        %##nreg##new offset## = add i64 %##reg##offset##, 1
        %##nreg##simd found char?## = icmp eq i64 %##reg##new n in simd look##, 0
        br i1 %##reg##simd found char?##, label %##reg##simd found label##, label %##reg##look loop##
        ##nreg##continue simd search##:
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##simd found label##:
        %##nreg##start index## = add i64 %##reg##remain chars 1##, %##reg##a##
        %##nreg##full simd index## = sub i64 %##reg##start index##, %##reg##offset##
        %##nreg##simd result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##full simd index##, 1
        ret [2 x i64] %##reg##simd result##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##range size##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##continue simd search##]
        %##nreg##n 2## = phi i64 [%##reg##n##, %##reg##start##], [%##reg##n in simd look##, %##reg##continue simd search##]
        %##nreg##vector address## = phi <16 x i16>* [%##reg##address##, %##reg##start##], [%##reg##address 1##, %##reg##continue simd search##]
        %##nreg##address 2## = bitcast <16 x i16>* %##reg##vector address## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##continue scalar search##]
        %##nreg##n 3## = phi i64 [%##reg##n 2##, %##reg##scalar label##], [%##reg##new n 3##, %##reg##continue scalar search##]
        %##nreg##after address 3## = phi i16* [%##reg##address 2##, %##reg##scalar label##], [%##reg##address 3##, %##reg##continue scalar search##]
        %##nreg##address 3## = getelementptr i16, i16* %##reg##after address 3##, i64 -1
        %##nreg##char from address## = load i16, i16* %##reg##address 3##, align 2
        %##nreg##found char?## = icmp eq i16 %##reg##char from address##, %##reg##char##
        %##nreg##found char? i64## = zext i1 %##reg##found char?## to i64
        %##nreg##new n 3## = sub i64 %##reg##n 3##, %##reg##found char? i64##
        %##nreg##final found char## = icmp eq i64 %##reg##new n 3##, 0
        br i1 %##reg##final found char##, label %##reg##final found char label##, label %##reg##continue scalar search##
        ##nreg##continue scalar search##:
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##final found char label##:
        %##nreg##full scalar index + 1## = add i64 %##reg##remain chars 3##, %##reg##a##
        %##nreg##full scalar index## = sub i64 %##reg##full scalar index + 1##, 1
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##full scalar index##, 1
        ret [2 x i64] %##reg##result##
        ##nreg##end label##:
        ret [2 x i64] zeroinitializer

#override(STD) inline
def lookBackNPartFromAtoB(string, part String, n, a, b Int) <>Int
    const partLength Int = part.length~()
    const stringLength Int = string.length~()
    inthrow
        if !(n > 0 && a >= 0 && a <= b && b <= stringLength)
            throw(enum::error_outOfRange, "Out of range.")
        if partLength == 0
            throw(enum::error_nothingToLook, "There is nothing to look for.")
    const firstEdge Int = b - partLength + 1
    if firstEdge > 0
        var mutN Int = n
        const firstChar Char = part.unsafe_getI16(8).unsafe_int_intToChar()
        for :(edge Int = firstEdge) edge > a
            const indexOfFirstChar <>Int = string.lookBackFromAtoB(firstChar, a, edge)
            if indexOfFirstChar.nothing?()
                end edge
            if string.partsEqual?(indexOfFirstChar, part, 0, partLength)
                if mutN == 1
                    return indexOfFirstChar
                mutN--
                edge = indexOfFirstChar - partLength + 1
            else
                edge = indexOfFirstChar
    return nothing

#override(STD) alwaysinline
def delete$(string String, from, count Int) String
    const oldLength Int = string.length~()
    const newLength Int = oldLength - count
    inthrow
        if {
            !(from >= 0 && from <= oldLength &&
            count >= 0 && count <= oldLength - from)
        }
            throw(enum::error_outOfRange, "Out of range.")
    var result String = unsafe_string_createDummy(newLength)
    const resultItems Int = result.unsafe_offsetI16(8)
    const stringItems Int = string.unsafe_offsetI16(8)
    unsafe_memcpyI16(resultItems, stringItems, from)
    unsafe_memcpyI16(resultItems.unsafe_offsetI16(from), stringItems.unsafe_offsetI16(from + count), oldLength - from - count)
    return result

#override(STD) alwaysinline
def delete(write string String, from, count Int)
    const oldLength Int = string.length~()
    inthrow
        if {
            !(from >= 0 && from <= oldLength &&
            count >= 0 && count <= oldLength - from)
        }
            throw(enum::error_outOfRange, "Out of range.")
    if count == 0
        return
    const newLength Int = oldLength - count
    const stringItems Int = string.unsafe_offsetI16(8)
    const lastPartIndex Int = from + count
    const lastPartLength Int = oldLength - lastPartIndex
    if string.use?()
        var newString String = unsafe_string_createDummy(newLength)
        const newItems Int = newString.unsafe_offsetI16(8)
        unsafe_memcpyI16(newItems, stringItems, from)
        unsafe_memcpyI16(newItems.unsafe_offsetI16(from), stringItems.unsafe_offsetI16(lastPartIndex), lastPartLength)
        string = newString
    else
        unsafe_memmoveI16(stringItems.unsafe_offsetI16(from), stringItems.unsafe_offsetI16(lastPartIndex), lastPartLength)
        string.unsafe_setI64(1, newLength)
        string.unsafe_realloc(16 + newLength * 2)

#override(STD) alwaysinline nothrow
def replace$(string String, oldChar, newChar Char) String
    const length Int = string.length~()
    var result String = unsafe_string_createDummy(length)
    unsafe_string_replace$(result.unsafe_offsetI16(8), string.unsafe_offsetI16(8), oldChar, newChar, length)
    return result

#alwaysinline nothrow
def unsafe_string_replace$(destination, source, oldChar, newChar, length $Any)
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##destination i64## = extractvalue [2 x i64] %0, 1
        %##nreg##destination## = inttoptr i64 %##reg##destination i64## to <16 x i16>*
        %##nreg##source i64## = extractvalue [2 x i64] %1, 1
        %##nreg##source## = inttoptr i64 %##reg##source i64## to <16 x i16>*
        %##nreg##old char 64## = extractvalue [2 x i64] %2, 1
        %##nreg##old char## = trunc i64 %##reg##old char 64## to i16
        %##nreg##new char 64## = extractvalue [2 x i64] %3, 1
        %##nreg##new char## = trunc i64 %##reg##new char 64## to i16
        %##nreg##length## = extractvalue [2 x i64] %4, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd label##, label %##reg##scalar label##
        ##nreg##simd label##:
        %##nreg##<1 x old char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##old char##, i32 0
        %##nreg##<16 x old char>## = shufflevector <1 x i16> %##reg##<1 x old char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        %##nreg##<1 x new char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##new char##, i32 0
        %##nreg##<16 x new char>## = shufflevector <1 x i16> %##reg##<1 x new char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        br label %##reg##simd loop##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##length##, %##reg##simd label##], [%##reg##new remain chars 1##, %##reg##simd loop##]
        %##nreg##destination 1## = phi <16 x i16>* [%##reg##destination##, %##reg##simd label##], [%##reg##new simd destination##, %##reg##simd loop##]
        %##nreg##source 1## = phi <16 x i16>* [%##reg##source##, %##reg##simd label##], [%##reg##new simd source##, %##reg##simd loop##]
        %##nreg##vector from source## = load <16 x i16>, <16 x i16>* %##reg##source 1##, align 2
        %##nreg##vector compare result## = icmp eq <16 x i16> %##reg##vector from source##, %##reg##<16 x old char>##
        %##nreg##vector from source with new char## = select <16 x i1> %##reg##vector compare result##, <16 x i16> %##reg##<16 x new char>##, <16 x i16> %##reg##vector from source##
        store <16 x i16> %##reg##vector from source with new char##, <16 x i16>* %##reg##destination 1##, align 2
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd destination## = getelementptr <16 x i16>, <16 x i16>* %##reg##destination 1##, i64 1
        %##nreg##new simd source## = getelementptr <16 x i16>, <16 x i16>* %##reg##source 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##simd loop##]
        %##nreg##vector destination 2## = phi <16 x i16>* [%##reg##destination##, %##reg##start##], [%##reg##new simd destination##, %##reg##simd loop##]
        %##nreg##vector source 2## = phi <16 x i16>* [%##reg##source##, %##reg##start##], [%##reg##new simd source##, %##reg##simd loop##]
        %##nreg##destination 2## = bitcast <16 x i16>* %##reg##vector destination 2## to i16*
        %##nreg##source 2## = bitcast <16 x i16>* %##reg##vector source 2## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##scalar loop##]
        %##nreg##destination 3## = phi i16* [%##reg##destination 2##, %##reg##scalar label##], [%##reg##new destination 3##, %##reg##scalar loop##]
        %##nreg##source 3## = phi i16* [%##reg##source 2##, %##reg##scalar label##], [%##reg##new source 3##, %##reg##scalar loop##]
        %##nreg##char from source## = load i16, i16* %##reg##source 3##, align 2
        %##nreg##old char?## = icmp eq i16 %##reg##char from source##, %##reg##old char##
        %##nreg##result char## = select i1 %##reg##old char?##, i16 %##reg##new char##, i16 %##reg##char from source##
        store i16 %##reg##result char##, i16* %##reg##destination 3##, align 2
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new destination 3## = getelementptr i16, i16* %##reg##destination 3##, i64 1
        %##nreg##new source 3## = getelementptr i16, i16* %##reg##source 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##end label##:
        ret [2 x i64] zeroinitializer

#override(STD) alwaysinline nothrow
def replace(write string String, oldChar, newChar Char)
    const length Int = string.length~()
    if string.use?()
        string = string.replace$(oldChar, newChar)
    else
        unsafe_string_replace(string.unsafe_offsetI16(8), oldChar, newChar, length)

#alwaysinline nothrow
def unsafe_string_replace(address, oldChar, newChar, length $Any)
    llvm
        br label %##reg##start##
        ##nreg##start##:
        %##nreg##address i64## = extractvalue [2 x i64] %0, 1
        %##nreg##address## = inttoptr i64 %##reg##address i64## to <16 x i16>*
        %##nreg##old char 64## = extractvalue [2 x i64] %1, 1
        %##nreg##old char## = trunc i64 %##reg##old char 64## to i16
        %##nreg##new char 64## = extractvalue [2 x i64] %2, 1
        %##nreg##new char## = trunc i64 %##reg##new char 64## to i16
        %##nreg##length## = extractvalue [2 x i64] %3, 1
        %##nreg##use simd## = icmp uge i64 %##reg##length##, 16
        br i1 %##reg##use simd##, label %##reg##simd label##, label %##reg##scalar label##
        ##nreg##simd label##:
        %##nreg##<1 x old char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##old char##, i32 0
        %##nreg##<16 x old char>## = shufflevector <1 x i16> %##reg##<1 x old char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        %##nreg##<1 x new char>## = insertelement <1 x i16> zeroinitializer, i16 %##reg##new char##, i32 0
        %##nreg##<16 x new char>## = shufflevector <1 x i16> %##reg##<1 x new char>##, <1 x i16> zeroinitializer, <16 x i32> zeroinitializer
        br label %##reg##simd loop##
        ##nreg##simd loop##:
        %##nreg##remain chars 1## = phi i64 [%##reg##length##, %##reg##simd label##], [%##reg##new remain chars 1##, %##reg##simd loop##]
        %##nreg##address 1## = phi <16 x i16>* [%##reg##address##, %##reg##simd label##], [%##reg##new simd address##, %##reg##simd loop##]
        %##nreg##vector from address## = load <16 x i16>, <16 x i16>* %##reg##address 1##, align 2
        %##nreg##vector compare result## = icmp eq <16 x i16> %##reg##vector from address##, %##reg##<16 x old char>##
        %##nreg##vector from address with new char## = select <16 x i1> %##reg##vector compare result##, <16 x i16> %##reg##<16 x new char>##, <16 x i16> %##reg##vector from address##
        store <16 x i16> %##reg##vector from address with new char##, <16 x i16>* %##reg##address 1##, align 2
        %##nreg##new remain chars 1## = sub i64 %##reg##remain chars 1##, 16
        %##nreg##new simd address## = getelementptr <16 x i16>, <16 x i16>* %##reg##address 1##, i64 1
        %##nreg##continue simd## = icmp uge i64 %##reg##new remain chars 1##, 16
        br i1 %##reg##continue simd##, label %##reg##simd loop##, label %##reg##scalar label##
        ##nreg##scalar label##:
        %##nreg##remain chars 2## = phi i64 [%##reg##length##, %##reg##start##], [%##reg##new remain chars 1##, %##reg##simd loop##]
        %##nreg##vector address 2## = phi <16 x i16>* [%##reg##address##, %##reg##start##], [%##reg##new simd address##, %##reg##simd loop##]
        %##nreg##address 2## = bitcast <16 x i16>* %##reg##vector address 2## to i16*
        %##nreg##continue 2## = icmp ne i64 %##reg##remain chars 2##, 0
        br i1 %##reg##continue 2##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##scalar loop##:
        %##nreg##remain chars 3## = phi i64 [%##reg##remain chars 2##, %##reg##scalar label##], [%##reg##new remain chars 3##, %##reg##scalar loop##]
        %##nreg##address 3## = phi i16* [%##reg##address 2##, %##reg##scalar label##], [%##reg##new address 3##, %##reg##scalar loop##]
        %##nreg##char from address## = load i16, i16* %##reg##address 3##, align 2
        %##nreg##old char?## = icmp eq i16 %##reg##char from address##, %##reg##old char##
        %##nreg##result char## = select i1 %##reg##old char?##, i16 %##reg##new char##, i16 %##reg##char from address##
        store i16 %##reg##result char##, i16* %##reg##address 3##, align 2
        %##nreg##new remain chars 3## = sub i64 %##reg##remain chars 3##, 1
        %##nreg##new address 3## = getelementptr i16, i16* %##reg##address 3##, i64 1
        %##nreg##continue 3## = icmp ne i64 %##reg##new remain chars 3##, 0
        br i1 %##reg##continue 3##, label %##reg##scalar loop##, label %##reg##end label##
        ##nreg##end label##:
        ret [2 x i64] zeroinitializer

#override(STD) alwaysinline
def insert$(string String, index Int, newChar Char) String
    const oldLength Int = string.length~()
    const newLength Int = oldLength + 1
    inthrow
        if !index.inRange?(0, newLength)
            throw(enum::error_outOfRange, "Out of range.")
    var result String = unsafe_string_createDummy(newLength)
    const resultChars Int = result.unsafe_offsetI16(8)
    const stringChars Int = string.unsafe_offsetI16(8)
    unsafe_memcpyI16(resultChars, stringChars, index)
    resultChars.unsafe_setI16(index, newChar)
    unsafe_memcpyI16(resultChars.unsafe_offsetI16(index + 1), stringChars.unsafe_offsetI16(index), oldLength - index)
    return result

#override(STD) alwaysinline
def insert(write string String, index Int, newChar Char)
    const oldLength Int = string.length~()
    const newLength Int = oldLength + 1
    inthrow
        if !index.inRange?(0, newLength)
            throw(enum::error_outOfRange, "Out of range.")
    if string.use?()
        var newString String = unsafe_string_createDummy(newLength)
        const newChars Int = newString.unsafe_offsetI16(8)
        const stringChars Int = string.unsafe_offsetI16(8)
        unsafe_memcpyI16(newChars, stringChars, index)
        newChars.unsafe_setI16(index, newChar)
        unsafe_memcpyI16(newChars.unsafe_offsetI16(index + 1), stringChars.unsafe_offsetI16(index), oldLength - index)
        string = newString
    else
        string.unsafe_setI64(1, newLength)
        string.unsafe_realloc(newLength * 2 + 16)
        const stringChars Int = string.unsafe_offsetI16(8)
        unsafe_memmoveI16(stringChars.unsafe_offsetI16(index + 1), stringChars.unsafe_offsetI16(index), oldLength - index)
        stringChars.unsafe_setI16(index, newChar)

#override(STD) inline
def insertPart$(string String, index Int, addedString String) String
    const oldLength Int = string.length~()
    const addedLength Int = addedString.length~()
    const newLength Int = oldLength + addedLength
    inthrow
        if !index.inRange?(0, oldLength + 1)
            throw(enum::error_outOfRange, "Out of range.")
    if addedLength == 0
        return string
    var result String = unsafe_string_createDummy(newLength)
    const resultChars Int = result.unsafe_offsetI16(8)
    const stringChars Int = string.unsafe_offsetI16(8)
    const addedChars Int = addedString.unsafe_offsetI16(8)
    unsafe_memcpyI16(resultChars, stringChars, index)
    unsafe_memcpyI16(resultChars.unsafe_offsetI16(index), addedChars, addedLength)
    unsafe_memcpyI16(resultChars.unsafe_offsetI16(index + addedLength), stringChars.unsafe_offsetI16(index), oldLength - index)
    return result

#override(STD) inline
def insertPart(write string String, index Int, addedString String)
    const oldLength Int = string.length~()
    const addedLength Int = addedString.length~()
    const newLength Int = oldLength + addedLength
    inthrow
        if !index.inRange?(0, oldLength + 1)
            throw(enum::error_outOfRange, "Out of range.")
    if addedLength == 0
        return
    const addedChars Int = addedString.unsafe_offsetI16(8)
    if string.use?()
        var newString String = unsafe_string_createDummy(newLength)
        const stringChars Int = string.unsafe_offsetI16(8)
        const newStringChars Int = newString.unsafe_offsetI16(8)
        unsafe_memcpyI16(newStringChars, stringChars, index)
        unsafe_memcpyI16(newStringChars.unsafe_offsetI16(index), addedChars, addedLength)
        unsafe_memcpyI16(newStringChars.unsafe_offsetI16(index + addedLength), stringChars.unsafe_offsetI16(index), oldLength - index)
        string = newString
    else
        string.unsafe_setI64(1, newLength)
        string.unsafe_realloc(newLength * 2 + 16)
        const stringChars Int = string.unsafe_offsetI16(8)
        unsafe_memmoveI16(stringChars.unsafe_offsetI16(index + addedLength), stringChars.unsafe_offsetI16(index), oldLength - index)
        unsafe_memcpyI16(stringChars.unsafe_offsetI16(index), addedChars, addedLength)

#override(STD) alwaysinline
def repeat(noread type String, char Char, count Int) String
    inthrow
        if count < 0
            throw(enum::error_outOfRange, "Out of range.")
    var result String = unsafe_string_createDummy(count)
    unsafe_memsetI16(result.unsafe_offsetI16(8), char, count)
    return result

#override(STD) alwaysinline
def repeatPart(part String, count Int) String
    inthrow
        if count < 0
            throw(enum::error_outOfRange, "Out of range.")
    const partLength Int = part.length~()
    const resultLength Int = count * partLength
    var result String = unsafe_string_createDummy(resultLength)
    const resultChars Int = result.unsafe_offsetI16(8)
    const partChars Int = part.unsafe_offsetI16(8)
    for :(index Int = 0) index < resultLength; index += partLength
        unsafe_memcpyI16(resultChars.unsafe_offsetI16(index), partChars, partLength)
    return result
