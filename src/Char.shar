module STD

//@String character implementation.
export primitive Char

attach Char to Independent

#override(STD) alwaysinline
def shar__rc_free(character Char)
    return nothing

#override(STD) alwaysinline
def shar__rc_use(character Char)
    return nothing

#override(STD) alwaysinline
def shar__to_const(character Char)
    return nothing

#override(STD) alwaysinline nothrow
def use?(character Char) Bool
    return false

#override(STD) alwaysinline nothrow
def constant?(character Char) Bool
    return false

#override(STD) alwaysinline nothrow
def clone(character Char) Char
    return character

attach Char to Equal

attach Char to Shar__sugar__equal
    #alwaysinline nothrow
    def shar__sugar__equal(character1, character2 Char) Bool
        llvm
            %##nreg##character1 i64## = extractvalue [2 x i64] %0, 1
            %##nreg##character2 i64## = extractvalue [2 x i64] %1, 1
            %##nreg##character1## = trunc i64 %##reg##character1 i64## to i16
            %##nreg##character2## = trunc i64 %##reg##character2 i64## to i16
            %##nreg##result i1## = icmp eq i16 %##reg##character1##, %##reg##character2##
            %##nreg##result i64## = zext i1 %##reg##result i1## to i64
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__notEqual
    #alwaysinline nothrow
    def shar__sugar__notEqual(character1, character2 Char) Bool
        llvm
            %##nreg##character1 i64## = extractvalue [2 x i64] %0, 1
            %##nreg##character2 i64## = extractvalue [2 x i64] %1, 1
            %##nreg##character1## = trunc i64 %##reg##character1 i64## to i16
            %##nreg##character2## = trunc i64 %##reg##character2 i64## to i16
            %##nreg##result i1## = icmp ne i16 %##reg##character1##, %##reg##character2##
            %##nreg##result i64## = zext i1 %##reg##result i1## to i64
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Ordered

attach Char to Shar__sugar__great
    #alwaysinline nothrow
    def shar__sugar__great(character1, character2 Char) Bool
        llvm
            %##nreg##character1 i64## = extractvalue [2 x i64] %0, 1
            %##nreg##character2 i64## = extractvalue [2 x i64] %1, 1
            %##nreg##character1## = trunc i64 %##reg##character1 i64## to i16
            %##nreg##character2## = trunc i64 %##reg##character2 i64## to i16
            %##nreg##result i1## = icmp ugt i16 %##reg##character1##, %##reg##character2##
            %##nreg##result i64## = zext i1 %##reg##result i1## to i64
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__greatOrEqual
    #alwaysinline nothrow
    def shar__sugar__greatOrEqual(character1, character2 Char) Bool
        llvm
            %##nreg##character1 i64## = extractvalue [2 x i64] %0, 1
            %##nreg##character2 i64## = extractvalue [2 x i64] %1, 1
            %##nreg##character1## = trunc i64 %##reg##character1 i64## to i16
            %##nreg##character2## = trunc i64 %##reg##character2 i64## to i16
            %##nreg##result i1## = icmp uge i16 %##reg##character1##, %##reg##character2##
            %##nreg##result i64## = zext i1 %##reg##result i1## to i64
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__less
    #alwaysinline nothrow
    def shar__sugar__less(character1, character2 Char) Bool
        llvm
            %##nreg##character1 i64## = extractvalue [2 x i64] %0, 1
            %##nreg##character2 i64## = extractvalue [2 x i64] %1, 1
            %##nreg##character1## = trunc i64 %##reg##character1 i64## to i16
            %##nreg##character2## = trunc i64 %##reg##character2 i64## to i16
            %##nreg##result i1## = icmp ult i16 %##reg##character1##, %##reg##character2##
            %##nreg##result i64## = zext i1 %##reg##result i1## to i64
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__lessOrEqual
    #alwaysinline nothrow
    def shar__sugar__lessOrEqual(character1, character2 Char) Bool
        llvm
            %##nreg##character1 i64## = extractvalue [2 x i64] %0, 1
            %##nreg##character2 i64## = extractvalue [2 x i64] %1, 1
            %##nreg##character1## = trunc i64 %##reg##character1 i64## to i16
            %##nreg##character2## = trunc i64 %##reg##character2 i64## to i16
            %##nreg##result i1## = icmp ule i16 %##reg##character1##, %##reg##character2##
            %##nreg##result i64## = zext i1 %##reg##result i1## to i64
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__and
    #alwaysinline nothrow
    def shar__sugar__and(character1, character2 Char) Char
        llvm
            %##nreg##character1## = extractvalue [2 x i64] %0, 1
            %##nreg##character2## = extractvalue [2 x i64] %1, 1
            %##nreg##result i64## = and i64 %##reg##character1##, %##reg##character2##
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Char##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__xor
    #alwaysinline nothrow
    def shar__sugar__xor(character1, character2 Char) Char
        llvm
            %##nreg##character1## = extractvalue [2 x i64] %0, 1
            %##nreg##character2## = extractvalue [2 x i64] %1, 1
            %##nreg##result i64## = xor i64 %##reg##character1##, %##reg##character2##
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Char##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__or
    #alwaysinline nothrow
    def shar__sugar__or(character1, character2 Char) Char
        llvm
            %##nreg##character1## = extractvalue [2 x i64] %0, 1
            %##nreg##character2## = extractvalue [2 x i64] %1, 1
            %##nreg##result i64## = or i64 %##reg##character1##, %##reg##character2##
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Char##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__shl
    #alwaysinline
    def shar__sugar__shl(character Char, shifts Int) Char
        inthrow
            if !shifts.inRange?(0, 16)
                throw(enum::error_invalidShiftsNumber, "Invalid number of shifts.")
        return character.unsafe_char_shl(shifts)

#alwaysinline nothrow
def unsafe_char_shl(character, shifts $Any) Char
    llvm
        %##nreg##character## = extractvalue [2 x i64] %0, 1
        %##nreg##shifts## = extractvalue [2 x i64] %1, 1
        %##nreg##result i64## = shl i64 %##reg##character##, %##reg##shifts##
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Char##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__shr
    #alwaysinline
    def shar__sugar__shr(character Char, shifts Int) Char
        inthrow
            if !shifts.inRange?(0, 16)
                throw(enum::error_invalidShiftsNumber, "Invalid number of shifts.")
        return character.unsafe_char_shr(shifts)

#alwaysinline nothrow
def unsafe_char_shr(character, shifts $Any) Char
    llvm
        %##nreg##character## = extractvalue [2 x i64] %0, 1
        %##nreg##shifts## = extractvalue [2 x i64] %1, 1
        %##nreg##character i16## = trunc i64 %##reg##character## to i16
        %##nreg##shifts i16## = trunc i64 %##reg##shifts## to i16
        %##nreg##result i16## = lshr i16 %##reg##character i16##, %##reg##shifts i16##
        %##nreg##result i64## = zext i16 %##reg##result i16## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Char##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

attach Char to Shar__sugar__andSet
    #alwaysinline nothrow
    def shar__sugar__andSet(write character1, character2 Char)
        character1 = character1 & character2

attach Char to Shar__sugar__xorSet
    #alwaysinline nothrow
    def shar__sugar__xorSet(write character1, character2 Char)
        character1 = character1 ^ character2

attach Char to Shar__sugar__orSet
    #alwaysinline nothrow
    def shar__sugar__orSet(write character1, character2 Char)
        character1 = character1 | character2

attach Char to Shar__sugar__shlSet
    #alwaysinline
    def shar__sugar__shlSet(write character Char, shifts Int)
        character = character << shifts

attach Char to Shar__sugar__shrSet
    #alwaysinline
    def shar__sugar__shrSet(write character Char, shifts Int)
        character = character >> shifts

//@An object of type "STD::Char", when represented as an array of bits, is always 32 bits.
attach Char to BitArray
    #alwaysinline
    def getBit(character Char, index Int) Bool
        inthrow
            if !index.inRange?(0, 16)
                throw(enum::error_outOfRange, "Out of range.")
        return ((character >> index) & '\0001') == '\0001'

    #alwaysinline
    def setBit$(character Char, index Int, newBit Bool) Char
        inthrow
            if !index.inRange?(0, 16)
                throw(enum::error_outOfRange, "Out of range.")
        const characterWithBit Char = '\0001' << index
        if newBit
            return character | characterWithBit
        else
            return character & ('\ffff' ^ characterWithBit)

    #alwaysinline
    def setBit(write character Char, index Int, newBit Bool)
        inthrow
            if !index.inRange?(0, 16)
                throw(enum::error_outOfRange, "Out of range.")
        const characterWithBit Char = '\0001' << index
        if newBit
            character |= characterWithBit
        else
            character &= '\ffff' ^ characterWithBit

    #alwaysinline nothrow
    def bitsCount~(character Char) Int
        return 16

    #alwaysinline nothrow
    def not(character Char) Char
        llvm
            %##nreg##character## = extractvalue [2 x i64] %0, 1
            %##nreg##result i64## = xor i64 %##reg##character##, -1
            %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Char##, i64 0], i64 %##reg##result i64##, 1
            ret [2 x i64] %##reg##result##

attach Char to StringWriter
    //@The function returns an object of type "STD::String".
    #alwaysinline nothrow
    def toString(character Char) String
        var result String = unsafe_string_createDummy(1)
        result.unsafe_setI16(8, character.unsafe_getValue())
        return result

#override(STD) alwaysinline nothrow
def print(character Char)
    llvm
        %##nreg##char memory## = alloca i16, align 2
        %##nreg##char i64## = extractvalue [2 x i64] %0, 1
        %##nreg##char## = trunc i64 %##reg##char i64## to i16
        store i16 %##reg##char##, i16* %##reg##char memory##, align 2
        call void @shar__print__string(i64 1, i16* %##reg##char memory##)
        ret [2 x i64] zeroinitializer

#override(STD) alwaysinline nothrow
def println(character Char)
    llvm
        %##nreg##char memory## = alloca i16, align 2
        %##nreg##char i64## = extractvalue [2 x i64] %0, 1
        %##nreg##char## = trunc i64 %##reg##char i64## to i16
        store i16 %##reg##char##, i16* %##reg##char memory##, align 2
        call void @shar__println__string(i64 1, i16* %##reg##char memory##)
        ret [2 x i64] zeroinitializer

#override(STD) nothrow
def printAsError(character Char)
    llvm
        %##nreg##char memory## = alloca i16, align 2
        %##nreg##char i64## = extractvalue [2 x i64] %0, 1
        %##nreg##char## = trunc i64 %##reg##char i64## to i16
        store i16 %##reg##char##, i16* %##reg##char memory##, align 2
        call void @shar__print__as__error(i64 1, i16* %##reg##char memory##)
        ret [2 x i64] zeroinitializer

#override(STD) nothrow
def printlnAsError(character Char)
    llvm
        %##nreg##char memory## = alloca i16, align 2
        %##nreg##char i64## = extractvalue [2 x i64] %0, 1
        %##nreg##char## = trunc i64 %##reg##char i64## to i16
        store i16 %##reg##char##, i16* %##reg##char memory##, align 2
        call void @shar__println__as__error(i64 1, i16* %##reg##char memory##)
        ret [2 x i64] zeroinitializer

attach Char to StringReader
    #alwaysinline
    def fromString(noread type Char, string $String) Char
        if string.length~() == 1
            return string[0]
        throw(enum::error_readFromString, "Reading from the string caused an error.")

#alwaysinline nothrow
export def charToInt(char Char) Int
    return char.unsafe_getValue() & 0xffff

attach Char to Hashable
    #alwaysinline nothrow
    def getHash(character Char) Int
        return charToInt(character)

    #alwaysinline nothrow
    def getRandomizedHash(character Char) Int
        return (character ^ (const::staticRandomNumber & 0xffff).unsafe_int_intToChar()).charToInt()

attach Char to BinarySerializable
    #alwaysinline nothrow
    def serialize(char Char, write bytes Bytes)
        const newLength Int = bytes.length~() + 2
        if bytes.use?()
            const newBytes Bytes = unsafe_bytes_createDummy(newLength)
            unsafe_memcpyI8(newBytes.unsafe_offsetI64(2), bytes.unsafe_offsetI64(2), bytes.length~())
            bytes = newBytes
        else
            bytes.unsafe_realloc(newLength + 16)
            bytes.unsafe_setI64(1, newLength)
        bytes.unsafe_offsetI8(newLength + 14).unsafe_setI16(0, char)

    #alwaysinline
    def deserialize(noread type Char, bytes Bytes, write position Int) Char
        inthrow
            if bytes.length~() - position < 2 || position < 0
                throw(enum::error_outOfRange, "Out of range.")
        const resultAsInt Int = bytes.unsafe_offsetI8(position + 16).unsafe_getI16(0)
        position += 2
        return resultAsInt.unsafe_int_intToChar()
