module STD

primitive DictNode

attach DictNode to Independent

#override(STD) alwaysinline
def shar__rc_free(node DictNode)
    return nothing

#override(STD) alwaysinline
def shar__rc_use(node DictNode)
    return nothing

#override(STD)
def shar__to_const(node DictNode)
    unreachable()

#alwaysinline nothrow
def unsafe_dictNode_toConst(node, keyTypeNumber $Any)
    if node.unsafe_dictNode_getCounter() != 0
        const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
        for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
            node.unsafe_dictNode_keysAndValuesWithSameHashPartToConst(hashPartIndex, keyTypeNumber)
        node.unsafe_dictNode_setCounter(0)

#override(STD) alwaysinline nothrow
def use?(node DictNode) Bool
    return node.unsafe_dictNode_getCounter() != 1

#override(STD) alwaysinline nothrow
def constant?(node DictNode) Bool
    return node.unsafe_dictNode_getCounter() == 0

#override(STD)
def clone(node DictNode) DictNode
    unreachable()

#nothrow
def unsafe_dictNode_clone(node, keyTypeNumber $Any) DictNode
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    if node.unsafe_dictNode_getCounter() != 0
        for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
            node.unsafe_dictNode_useKeysAndValuesWithSameHashPart(hashPartIndex, keyTypeNumber)
    const nodeSizeInI16 Int = hashPartsCount * 5 + 4
    var result $Any = unsafe_malloc(nodeSizeInI16 * 2)
    unsafe_memcpyI16(result, node, nodeSizeInI16)
    result.unsafe_setI64(0, (result.unsafe_getI64(0) & -281474976710656) | 1)
    result.unsafe_setType(DictNode.typeNumber~())
    for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
        const sourceArray Int = node.unsafe_getI64(hashPartIndex + 1)
        const countOfItems Int = sourceArray.unsafe_getI64(0)
        const destinationArray Int = unsafe_malloc(countOfItems * 24 + 8)
        unsafe_memcpyI64(destinationArray, sourceArray, countOfItems * 3 + 1)
        result.unsafe_setI64(hashPartIndex + 1, destinationArray)
    return result

#alwaysinline nothrow
def unsafe_dictNode_getCounter(node $Any) Int
    return node.unsafe_getI64(0) & 0xffffffffffff

#alwaysinline nothrow
def unsafe_dictNode_setCounter(node, newCounter $Any)
    node.unsafe_setI64(0, (node.unsafe_getI64(0) & -281474976710656) | (newCounter & 0xffffffffffff))

#inline nothrow
def unsafe_dictNode_getHashPartsCount(node $Any) Int
    return node.unsafe_getI16(3) + 1

#nothrow
def unsafe_dictNode_free(node, keyTypeNumber $Any)
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
        node.unsafe_dictNode_freeKeysAndValuesWithSameHashPart(hashPartIndex, keyTypeNumber)
        node.unsafe_getI64(hashPartIndex + 1).unsafe_free()
    node.unsafe_free()

#alwaysinline unsafewrite nothrow
def unsafe_dictNode_getValueByHash(node, hashPart, key, write keysIndex, write keysInsertIndex, write keyIndex, write keysEqualError $Any) $Any
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    const keysAndValues Int = node.unsafe_offsetI64(1)
    const hashParts Int = keysAndValues.unsafe_offsetI64(hashPartsCount)
    var found Bool = false
    if hashPartsCount != 65536
        var leftIndex Int = 0
        var rightEdge Int = hashPartsCount
        for :(loop)
            const length Int = rightEdge - leftIndex
            if length == 0
                keysInsertIndex = leftIndex
                return nothing
            const centerIndex Int = (length >> 1) + leftIndex
            const centerHashPart Int = hashParts.unsafe_getI16(centerIndex)
            if centerHashPart == hashPart
                keysIndex = centerIndex
                found = true
                end loop
            if centerHashPart < hashPart
                leftIndex = centerIndex + 1
            else
                rightEdge = centerIndex
    else
        keysIndex = hashPart
        found = true
    if found
        const keysAndValuesWithSameHashPart_withCount Int = keysAndValues.unsafe_getI64(keysIndex)
        const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
        const keysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(1)
        for :(keyInNodeIndex Int = 0) keyInNodeIndex < countOfKeysAndValuesWithSameHashPart; keyInNodeIndex++
            var keyInNode $Any = keysAndValuesWithSameHashPart.unsafe_getI64(keyInNodeIndex * 3)
            keyInNode.unsafe_setType(key.typeNumber~())
            found = false
            try
                found = keyInNode == key
            catch id, message
                keyInNode.unsafe_setType(Int.typeNumber~())
                keysEqualError = {id, message}
                return nothing
            keyInNode.unsafe_setType(Int.typeNumber~())
            if found
                keyIndex = keyInNodeIndex
                var result $Any = 0
                keysAndValuesWithSameHashPart.unsafe_offsetI64(keyInNodeIndex * 3 + 1).unsafe_get2xI64(0, result)
                return result
    return nothing

#inline nothrow
def unsafe_dictNode_createNewNode(hashPart, key, value $Any) DictNode
    const countAndKeyAndValue Int = unsafe_malloc(32)
    countAndKeyAndValue.unsafe_setI64(0, 1)
    countAndKeyAndValue.unsafe_setI64(1, key)
    countAndKeyAndValue.unsafe_set2xI64(1, value)
    var result $Any = unsafe_malloc(18)
    result.unsafe_setI64(0, 1)
    result.unsafe_setI64(1, countAndKeyAndValue)
    result.unsafe_setI16(8, hashPart)
    result.unsafe_setType(DictNode.typeNumber~())
    return result

#unsafewrite nothrow
def unsafe_dictNode_deleteValue(write node, keysIndex, keyIndex, keyTypeNumber $Any)
    const keysAndValues Int = node.unsafe_offsetI64(1)
    var keysAndValuesWithSameHashPart_withCount Int = keysAndValues.unsafe_getI64(keysIndex)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    const keyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(keyIndex * 3 + 1)
    var key $Any = keyAddress.unsafe_getI64(0)
    key.unsafe_setType(keyTypeNumber)
    if countOfKeysAndValuesWithSameHashPart == 1
        keysAndValuesWithSameHashPart_withCount.unsafe_free()
        const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
        if hashPartsCount == 1
            node.unsafe_free()
            node = nothing
        else
            node.unsafe_setI16(3, hashPartsCount - 2)
            const hashParts Int = keysAndValues.unsafe_offsetI64(hashPartsCount)
            const countOfMovedHashParts Int = hashPartsCount - 1 - keysIndex
            const countOfMovedKVAndMovedHashPartsInI16 Int = countOfMovedHashParts * 4 + hashPartsCount - 1
            unsafe_memmoveI16(hashParts.unsafe_offsetI16(keysIndex), hashParts.unsafe_offsetI16(keysIndex + 1), countOfMovedHashParts)
            unsafe_memmoveI16(keysAndValues.unsafe_offsetI64(keysIndex), keysAndValues.unsafe_offsetI64(keysIndex + 1), countOfMovedKVAndMovedHashPartsInI16)
            node.unsafe_realloc(hashPartsCount * 10 - 2)
    else
        keysAndValuesWithSameHashPart_withCount.unsafe_setI64(0, countOfKeysAndValuesWithSameHashPart - 1)
        const lastIndexOffset Int = countOfKeysAndValuesWithSameHashPart * 3 - 2
        const lastKeyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(lastIndexOffset)
        unsafe_memmoveI64(keyAddress, lastKeyAddress, 3)
        keysAndValuesWithSameHashPart_withCount.unsafe_realloc(lastIndexOffset * 8)
        keysAndValues.unsafe_setI64(keysIndex, keysAndValuesWithSameHashPart_withCount)

#inline unsafewrite nothrow
def unsafe_dictNode_addKVWithNewHashCode(write node, hashPart, keysInsertIndex, key, value $Any)
    const countAndKeyAndValue Int = unsafe_malloc(32)
    countAndKeyAndValue.unsafe_setI64(0, 1)
    countAndKeyAndValue.unsafe_setI64(1, key)
    countAndKeyAndValue.unsafe_set2xI64(1, value)
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    node.unsafe_realloc(hashPartsCount * 10 + 18)
    const oldKeysAndValuesInNewNode Int = node.unsafe_offsetI64(1)
    const oldHashPartsInNewNode Int = oldKeysAndValuesInNewNode.unsafe_offsetI64(hashPartsCount)
    const countOfMovedHashPartsInEnd Int = hashPartsCount - keysInsertIndex
    const countOfMovedKVAndHashPartsInBeginInI16 Int = countOfMovedHashPartsInEnd * 4 + keysInsertIndex
    unsafe_memmoveI16(oldHashPartsInNewNode.unsafe_offsetI16(keysInsertIndex + 5), oldHashPartsInNewNode.unsafe_offsetI16(keysInsertIndex), countOfMovedHashPartsInEnd)
    node.unsafe_setI16(3, hashPartsCount)
    unsafe_memmoveI16(oldKeysAndValuesInNewNode.unsafe_offsetI64(keysInsertIndex + 1), oldKeysAndValuesInNewNode.unsafe_offsetI64(keysInsertIndex), countOfMovedKVAndHashPartsInBeginInI16)
    oldKeysAndValuesInNewNode.unsafe_setI64(keysInsertIndex, countAndKeyAndValue)
    oldHashPartsInNewNode.unsafe_setI16(keysInsertIndex + 4, hashPart)

#alwaysinline nothrow
def unsafe_dictNode_addKVWithExistedHashCode(node, keysIndex, keyIndex, key, value $Any)
    var keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    if keyIndex == -1
        keysAndValuesWithSameHashPart_withCount.unsafe_setI64(0, countOfKeysAndValuesWithSameHashPart + 1)
        const newKeyOffset Int = countOfKeysAndValuesWithSameHashPart * 3 + 1
        keysAndValuesWithSameHashPart_withCount.unsafe_realloc(newKeyOffset * 8 + 24)
        node.unsafe_setI64(keysIndex + 1, keysAndValuesWithSameHashPart_withCount)
        const newKeyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(newKeyOffset)
        const newValueAddress Int = newKeyAddress.unsafe_offsetI64(1)
        newKeyAddress.unsafe_setI64(0, key)
        newValueAddress.unsafe_set2xI64(0, value)
    else
        const newKeyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(keyIndex * 3 + 1)
        const newValueAddress Int = newKeyAddress.unsafe_offsetI64(1)
        var oldKey $Any = newKeyAddress.unsafe_getI64(0)
        oldKey.unsafe_setType(key.typeNumber~())
        newKeyAddress.unsafe_setI64(0, key)
        newValueAddress.unsafe_set2xI64(0, value)

#alwaysinline nothrow
def unsafe_dictNode_keysAndValuesWithSameHashPartToConst(node, keysAndValuesIndex, keyTypeNumber $Any)
    const keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysAndValuesIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    for :(keyOffset Int = 1) keyOffset < countOfKeysAndValuesWithSameHashPart * 3; keyOffset += 3
        var key $Any = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset)
        key.unsafe_setType(keyTypeNumber)
        key.shar__to_const()
        var value $Any = 0
        keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(keyOffset + 1).unsafe_get2xI64(0, value)
        value.shar__to_const()

#alwaysinline nothrow
def unsafe_dictNode_useKeysAndValuesWithSameHashPart(node, keysAndValuesIndex, keyTypeNumber $Any)
    const keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysAndValuesIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    for :(keyOffset Int = 1) keyOffset < countOfKeysAndValuesWithSameHashPart * 3; keyOffset += 3
        var key $Any = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset)
        key.unsafe_setType(keyTypeNumber)
        key.shar__rc_use()
        key.unsafe_setType(Int.typeNumber~())
        var value $Any = 0
        keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(keyOffset + 1).unsafe_get2xI64(0, value)
        value.shar__rc_use()
        value.unsafe_setType(Int.typeNumber~())

#alwaysinline nothrow
def unsafe_dictNode_freeKeysAndValuesWithSameHashPart(node, keysAndValuesIndex, keyTypeNumber $Any)
    const keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysAndValuesIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    for :(keyOffset Int = 1) keyOffset < countOfKeysAndValuesWithSameHashPart * 3; keyOffset += 3
        var key $Any = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset)
        key.unsafe_setType(keyTypeNumber)
        var value $Any = 0
        keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(keyOffset + 1).unsafe_get2xI64(0, value)
