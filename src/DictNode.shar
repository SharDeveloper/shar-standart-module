module STD

primitive DictNode

attach DictNode to Independent

#override(STD) alwaysinline
def shar__rc_free(node DictNode)
    return nothing

#override(STD) alwaysinline
def shar__rc_use(node DictNode)
    return nothing

#override(STD)
def shar__to_const(node DictNode)
    unreachable()

#alwaysinline nothrow
def unsafe_dictNode_toConst(node, keyTypeNumber $Any)
    if node.unsafe_dictNode_getCounter() != 0
        const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
        for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
            node.unsafe_dictNode_keysAndValuesWithSameHashPartToConst(hashPartIndex, keyTypeNumber)
        node.unsafe_dictNode_setCounter(0)

#override(STD) alwaysinline nothrow
def use?(node DictNode) Bool
    return node.unsafe_dictNode_getCounter() != 1

#override(STD) alwaysinline nothrow
def constant?(node DictNode) Bool
    return node.unsafe_dictNode_getCounter() == 0

#override(STD)
def clone(node DictNode) DictNode
    unreachable()

#nothrow
def unsafe_dictNode_clone(node, keyTypeNumber $Any) DictNode
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    if node.unsafe_dictNode_getCounter() != 0
        for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
            node.unsafe_dictNode_useKeysAndValuesWithSameHashPart(hashPartIndex, keyTypeNumber)
    const nodeSizeInI16 Int = hashPartsCount * 5 + 4
    const result DictNode = unsafe_object(DictNode.typeNumber~(), unsafe_malloc(nodeSizeInI16 * 2))
    unsafe_memcpyI16(result, node, nodeSizeInI16)
    result.unsafe_setI64(0, (result.unsafe_getI64(0) & -281474976710656) | 1)
    for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
        const sourceArray Int = node.unsafe_getI64(hashPartIndex + 1)
        const countOfItems Int = sourceArray.unsafe_getI64(0)
        const destinationArray Int = unsafe_malloc(countOfItems * 24 + 8)
        unsafe_memcpyI64(destinationArray, sourceArray, countOfItems * 3 + 1)
        result.unsafe_setI64(hashPartIndex + 1, destinationArray)
    return result

#alwaysinline nothrow
def unsafe_dictNode_getCounter(node $Any) Int
    return node.unsafe_getI64(0) & 0xffffffffffff

#alwaysinline nothrow
def unsafe_dictNode_setCounter(node, newCounter $Any)
    node.unsafe_setI64(0, (node.unsafe_getI64(0) & -281474976710656) | (newCounter & 0xffffffffffff))

#inline nothrow
def unsafe_dictNode_getHashPartsCount(node $Any) Int
    return node.unsafe_getI16(3) + 1

#nothrow
def unsafe_dictNode_free(node, keyTypeNumber $Any)
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    for :(hashPartIndex Int = 0) hashPartIndex < hashPartsCount; hashPartIndex++
        node.unsafe_dictNode_freeKeysAndValuesWithSameHashPart(hashPartIndex, keyTypeNumber)
        node.unsafe_getI64(hashPartIndex + 1).unsafe_free()
    node.unsafe_free()

#alwaysinline unsafewrite nothrow
def unsafe_dictNode_getValueByHash(node, hashPart, key, write keysIndex, write keysInsertIndex, write keyIndex, write keysEqualError $Any) $Any
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    const keysAndValues Int = node.unsafe_offsetI64(1)
    const hashParts Int = keysAndValues.unsafe_offsetI64(hashPartsCount)
    var found Bool = false
    if hashPartsCount != 65536
        var leftIndex Int = 0
        var rightEdge Int = hashPartsCount
        for :(loop)
            const length Int = rightEdge - leftIndex
            if length == 0
                keysInsertIndex = leftIndex
                return nothing
            const centerIndex Int = (length >> 1) + leftIndex
            const centerHashPart Int = hashParts.unsafe_getI16(centerIndex)
            if centerHashPart == hashPart
                keysIndex = centerIndex
                found = true
                end loop
            if centerHashPart < hashPart
                leftIndex = centerIndex + 1
            else
                rightEdge = centerIndex
    else
        keysIndex = hashPart
        found = true
    if found
        const keysAndValuesWithSameHashPart_withCount Int = keysAndValues.unsafe_getI64(keysIndex)
        const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
        const keysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(1)
        for :(keyInNodeIndex Int = 0) keyInNodeIndex < countOfKeysAndValuesWithSameHashPart; keyInNodeIndex++
            found = false
            try
                found = unsafe_equal(key.typeNumber~(), keysAndValuesWithSameHashPart.unsafe_getI64(keyInNodeIndex * 3), key.typeNumber~(), key)
            catch id, message
                keysEqualError = {id, message}
                return nothing
            if found
                keyIndex = keyInNodeIndex
                const offset Int = keyInNodeIndex * 3 + 1
                return unsafe_object(keysAndValuesWithSameHashPart.unsafe_getI64(offset), keysAndValuesWithSameHashPart.unsafe_getI64(offset + 1))
    return nothing

#inline nothrow
def unsafe_dictNode_createNewNode(hashPart, key, value $Any) DictNode
    const countAndKeyAndValue Int = unsafe_malloc(32)
    countAndKeyAndValue.unsafe_setI64(0, 1)
    countAndKeyAndValue.unsafe_setI64(1, key)
    countAndKeyAndValue.unsafe_set2xI64(1, value)
    const result DictNode = unsafe_object(DictNode.typeNumber~(), unsafe_malloc(18))
    result.unsafe_setI64(0, 1)
    result.unsafe_setI64(1, countAndKeyAndValue)
    result.unsafe_setI16(8, hashPart)
    return result

#unsafewrite nothrow
def unsafe_dictNode_deleteValue(write node, keysIndex, keyIndex, keyTypeNumber $Any)
    const keysAndValues Int = node.unsafe_offsetI64(1)
    var keysAndValuesWithSameHashPart_withCount Int = keysAndValues.unsafe_getI64(keysIndex)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    const keyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(keyIndex * 3 + 1)
    const freeKeyValue Int = keyAddress.unsafe_getI64(0)
    if countOfKeysAndValuesWithSameHashPart == 1
        keysAndValuesWithSameHashPart_withCount.unsafe_free()
        const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
        if hashPartsCount == 1
            node.unsafe_free()
            node = nothing
        else
            node.unsafe_setI16(3, hashPartsCount - 2)
            const hashParts Int = keysAndValues.unsafe_offsetI64(hashPartsCount)
            const countOfMovedHashParts Int = hashPartsCount - 1 - keysIndex
            const countOfMovedKVAndMovedHashPartsInI16 Int = countOfMovedHashParts * 4 + hashPartsCount - 1
            unsafe_memmoveI16(hashParts.unsafe_offsetI16(keysIndex), hashParts.unsafe_offsetI16(keysIndex + 1), countOfMovedHashParts)
            unsafe_memmoveI16(keysAndValues.unsafe_offsetI64(keysIndex), keysAndValues.unsafe_offsetI64(keysIndex + 1), countOfMovedKVAndMovedHashPartsInI16)
            node.unsafe_realloc(hashPartsCount * 10 - 2)
    else
        keysAndValuesWithSameHashPart_withCount.unsafe_setI64(0, countOfKeysAndValuesWithSameHashPart - 1)
        const lastIndexOffset Int = countOfKeysAndValuesWithSameHashPart * 3 - 2
        const lastKeyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(lastIndexOffset)
        unsafe_memmoveI64(keyAddress, lastKeyAddress, 3)
        keysAndValuesWithSameHashPart_withCount.unsafe_realloc(lastIndexOffset * 8)
        keysAndValues.unsafe_setI64(keysIndex, keysAndValuesWithSameHashPart_withCount)
    unsafe_object(keyTypeNumber, freeKeyValue)

#inline unsafewrite nothrow
def unsafe_dictNode_addKVWithNewHashCode(write node, hashPart, keysInsertIndex, key, value $Any)
    const countAndKeyAndValue Int = unsafe_malloc(32)
    countAndKeyAndValue.unsafe_setI64(0, 1)
    countAndKeyAndValue.unsafe_setI64(1, key)
    countAndKeyAndValue.unsafe_set2xI64(1, value)
    const hashPartsCount Int = node.unsafe_dictNode_getHashPartsCount()
    node.unsafe_realloc(hashPartsCount * 10 + 18)
    const oldKeysAndValuesInNewNode Int = node.unsafe_offsetI64(1)
    const oldHashPartsInNewNode Int = oldKeysAndValuesInNewNode.unsafe_offsetI64(hashPartsCount)
    const countOfMovedHashPartsInEnd Int = hashPartsCount - keysInsertIndex
    const countOfMovedKVAndHashPartsInBeginInI16 Int = countOfMovedHashPartsInEnd * 4 + keysInsertIndex
    unsafe_memmoveI16(oldHashPartsInNewNode.unsafe_offsetI16(keysInsertIndex + 5), oldHashPartsInNewNode.unsafe_offsetI16(keysInsertIndex), countOfMovedHashPartsInEnd)
    node.unsafe_setI16(3, hashPartsCount)
    unsafe_memmoveI16(oldKeysAndValuesInNewNode.unsafe_offsetI64(keysInsertIndex + 1), oldKeysAndValuesInNewNode.unsafe_offsetI64(keysInsertIndex), countOfMovedKVAndHashPartsInBeginInI16)
    oldKeysAndValuesInNewNode.unsafe_setI64(keysInsertIndex, countAndKeyAndValue)
    oldHashPartsInNewNode.unsafe_setI16(keysInsertIndex + 4, hashPart)

#alwaysinline nothrow
def unsafe_dictNode_addKVWithExistedHashCode(node, keysIndex, keyIndex, key, value $Any)
    var keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    if keyIndex == -1
        keysAndValuesWithSameHashPart_withCount.unsafe_setI64(0, countOfKeysAndValuesWithSameHashPart + 1)
        const newKeyOffset Int = countOfKeysAndValuesWithSameHashPart * 3 + 1
        keysAndValuesWithSameHashPart_withCount.unsafe_realloc(newKeyOffset * 8 + 24)
        node.unsafe_setI64(keysIndex + 1, keysAndValuesWithSameHashPart_withCount)
        const newKeyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(newKeyOffset)
        const newValueAddress Int = newKeyAddress.unsafe_offsetI64(1)
        newKeyAddress.unsafe_setI64(0, key)
        newValueAddress.unsafe_set2xI64(0, value)
    else
        const newKeyAddress Int = keysAndValuesWithSameHashPart_withCount.unsafe_offsetI64(keyIndex * 3 + 1)
        const newValueAddress Int = newKeyAddress.unsafe_offsetI64(1)
        unsafe_object(key.typeNumber~(), newKeyAddress.unsafe_getI64(0))
        newKeyAddress.unsafe_setI64(0, key)
        newValueAddress.unsafe_set2xI64(0, value)

#alwaysinline nothrow
def unsafe_dictNode_keysAndValuesWithSameHashPartToConst(node, keysAndValuesIndex, keyTypeNumber $Any)
    const keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysAndValuesIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    for :(keyOffset Int = 1) keyOffset < countOfKeysAndValuesWithSameHashPart * 3; keyOffset += 3
        unsafe_object(keyTypeNumber, keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset)).shar__to_const()
        unsafe_object(keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset + 1), keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset + 2)).shar__to_const()

#alwaysinline nothrow
def unsafe_dictNode_useKeysAndValuesWithSameHashPart(node, keysAndValuesIndex, keyTypeNumber $Any)
    const keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysAndValuesIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    for :(keyOffset Int = 1) keyOffset < countOfKeysAndValuesWithSameHashPart * 3; keyOffset += 3
        unsafe_use_object(keyTypeNumber, keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset))
        unsafe_use_object(keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset + 1), keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset + 2))

#alwaysinline nothrow
def unsafe_dictNode_freeKeysAndValuesWithSameHashPart(node, keysAndValuesIndex, keyTypeNumber $Any)
    const keysAndValuesWithSameHashPart_withCount Int = node.unsafe_getI64(keysAndValuesIndex + 1)
    const countOfKeysAndValuesWithSameHashPart Int = keysAndValuesWithSameHashPart_withCount.unsafe_getI64(0)
    for :(keyOffset Int = 1) keyOffset < countOfKeysAndValuesWithSameHashPart * 3; keyOffset += 3
        unsafe_object(keyTypeNumber, keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset))
        unsafe_object(keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset + 1), keysAndValuesWithSameHashPart_withCount.unsafe_getI64(keyOffset + 2))
