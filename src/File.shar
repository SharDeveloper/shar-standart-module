module STD

export primitive File

export enum
    fmode_read
    fmode_write
    fmode_append
    fmode_readAndWriteFromBegin
    fmode_readAndWriteNew
    fmode_readAndWriteFromEnd

#alwaysinline
def sharModeToCMode(sharFMode Int) Int
    eSwitch sharFMode
    case fmode_read
        return 25202
    case fmode_write
        return 25207
    case fmode_append
        return 25185
    case fmode_readAndWriteFromBegin
        return 6433650
    case fmode_readAndWriteNew
        return 6433655
    case fmode_readAndWriteFromEnd
        return 6433633
    inthrow
        throw(enum::error_invalidFileMode, "Invalid file open mode.")

#override(STD) alwaysinline
def shar__rc_free(file File)
    const counter Int = file.unsafe_getI64(0)
    if counter > 1
        file.unsafe_setI64(0, counter - 1)
    elif counter == 1
        unsafe_file_closeFile(file)
        file.unsafe_free()

#override(STD) alwaysinline
def shar__rc_use(file File)
    const counter Int = file.unsafe_getI64(0)
    if counter != 0
        file.unsafe_setI64(0, counter + 1)

#override(STD)
def shar__to_const(file File)
    if file.unsafe_getI64(0) != 0
        file.unsafe_setI64(0, 0)

#override(STD) alwaysinline nothrow
def use?(file File) Bool
    return file.unsafe_getI64(0) != 1

#override(STD) alwaysinline nothrow
def constant?(file File) Bool
    return file.unsafe_getI64(0) == 0

#override(STD) cold
def clone(file File) File
    throw(enum::error_clone, "Files cannot be cloned.")

//@The function flushes the output buffer.
//@If the flushed was successful, then the function returns "true", otherwise "false".
#alwaysinline nothrow
export def flushFile(file File) Bool
    llvm
        %##nreg##file memory## = extractvalue [2 x i64] %0, 1
        %##nreg##file memory i64*## = inttoptr i64 %##reg##file memory## to  i64*
        %##nreg##file pointer## = getelementptr i64, i64* %##reg##file memory i64*##, i64 1
        %##nreg##file i64## = load i64, i64* %##reg##file pointer##, align 8
        %##nreg##file## = inttoptr i64 %##reg##file i64## to i8*
        %##nreg##result i1## = call i1 @shar__flush__file(i8* %##reg##file##)
        %##nreg##result i64## = zext i1 %##reg##result i1## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

//The function flushes the output buffer and close the file.
#alwaysinline nothrow
def unsafe_file_closeFile(file $Any)
    llvm
        %##nreg##file memory## = extractvalue [2 x i64] %0, 1
        %##nreg##file memory i64*## = inttoptr i64 %##reg##file memory## to  i64*
        %##nreg##file pointer## = getelementptr i64, i64* %##reg##file memory i64*##, i64 1
        %##nreg##file i64## = load i64, i64* %##reg##file pointer##, align 8
        %##nreg##file## = inttoptr i64 %##reg##file i64## to i8*
        %##nreg##unneeded## = call i1 @shar__close__file(i8* %##reg##file##)
        ret [2 x i64] zeroinitializer

//@The function reads the specified number of bytes from the file into the third argument of the function and returns the number of bytes that were actually read.
//@If there is not enough space in the third argument to read the specified number of bytes, then the array of bytes in the third argument is expanded to the required size.
//@If the function has read less data than it needs, then the content of the unused data in the third argument is undefined.
//@If the specified number of bytes is less than zero, the function returns an error with the "enum::STD::error_outOfRange" code.
//@If the first argument is in several places in the program, then the function returns an error with the code "enum::STD::error_notASingleCopy".
#alwaysinline
export def readDataFromFile(file File, countOfBytes Int, write buffer Bytes) Int
    inthrow
        if file.use?()
            throw(enum::error_notASingleCopy, "Not a single copy.")
        if countOfBytes < 0
            throw(enum::error_outOfRange, "Out of range.")
    if buffer.length~() < countOfBytes
        if buffer.use?()
            buffer = Bytes.repeat(0, countOfBytes)
        else
            buffer.unsafe_realloc(countOfBytes + 16)
    elif buffer.use?()
        buffer = Bytes.repeat(0, buffer.length~())
    return unsafe_file_readDataFromFile(file, countOfBytes, buffer)

#alwaysinline nothrow
def unsafe_file_readDataFromFile(file, countOfBytes, buffer $Any) Int
    llvm
        %##nreg##file memory pointer i64## = extractvalue [2 x i64] %0, 1
        %##nreg##file memory pointer## = inttoptr i64 %##reg##file memory pointer i64## to i64*
        %##nreg##file pointer## = getelementptr i64, i64* %##reg##file memory pointer##, i64 1
        %##nreg##file i64## = load i64, i64* %##reg##file pointer##, align 8
        %##nreg##file## = inttoptr i64 %##reg##file i64## to i8*
        %##nreg##count of bytes## = extractvalue [2 x i64] %1, 1
        %##nreg##buffer with counter and length i64## = extractvalue [2 x i64] %2, 1
        %##nreg##buffer with counter and length## = inttoptr i64 %##reg##buffer with counter and length i64## to i8*
        %##nreg##buffer## = getelementptr i8, i8* %##reg##buffer with counter and length##, i64 16
        %##nreg##result i64## = call i64 @shar__read__from__file(i8* %##reg##file##, i64 %##reg##count of bytes##, i8* %##reg##buffer##)
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

//@The function writes the specified number of bytes from the byte array in the third argument to the function to a file and returns the number of bytes that were actually written.
//@If the specified number of bytes is less than zero, the function returns an error with the "enum::STD::error_outOfRange" code.
//@If the first argument is in several places in the program, then the function returns an error with the code "enum::STD::error_notASingleCopy".
#alwaysinline
export def writeDataToFile(file File, countOfBytes Int, buffer Bytes) Int
    inthrow
        if file.use?()
            throw(enum::error_notASingleCopy, "Not a single copy.")
        if countOfBytes < 0
            throw(enum::error_outOfRange, "Out of range.")
    return unsafe_file_writeDataToFile(file, countOfBytes, buffer)

#alwaysinline nothrow
def unsafe_file_writeDataToFile(file, countOfBytes, buffer $Any) Int
    llvm
        %##nreg##file memory pointer i64## = extractvalue [2 x i64] %0, 1
        %##nreg##file memory pointer## = inttoptr i64 %##reg##file memory pointer i64## to i64*
        %##nreg##file pointer## = getelementptr i64, i64* %##reg##file memory pointer##, i64 1
        %##nreg##file i64## = load i64, i64* %##reg##file pointer##, align 8
        %##nreg##file## = inttoptr i64 %##reg##file i64## to i8*
        %##nreg##count of bytes## = extractvalue [2 x i64] %1, 1
        %##nreg##buffer with counter and length i64## = extractvalue [2 x i64] %2, 1
        %##nreg##buffer with counter and length## = inttoptr i64 %##reg##buffer with counter and length i64## to i8*
        %##nreg##buffer## = getelementptr i8, i8* %##reg##buffer with counter and length##, i64 16
        %##nreg##result i64## = call i64 @shar__write__to__file(i8* %##reg##file##, i64 %##reg##count of bytes##, i8* %##reg##buffer##)
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##

//@The function returns the current position in the file.
//@If the function was unable to get the current file position, then "Nothing" is returned as a result.
#alwaysinline nothrow
export def getCurrentFilePosition(file File) <>Int
    llvm
        %##nreg##file memory## = extractvalue [2 x i64] %0, 1
        %##nreg##file memory i64*## = inttoptr i64 %##reg##file memory## to  i64*
        %##nreg##file pointer## = getelementptr i64, i64* %##reg##file memory i64*##, i64 1
        %##nreg##file i64## = load i64, i64* %##reg##file pointer##, align 8
        %##nreg##file## = inttoptr i64 %##reg##file i64## to i8*
        %##nreg##result i64## = call i64 @shar__get__position__in__file(i8* %##reg##file##)
        %##nreg##result i64 >= 0## = icmp sge i64 %##reg##result i64##, 0
        br i1 %##reg##result i64 >= 0##, label %##reg##int label##, label %##reg##nothing label##
        ##nreg##int label##:
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Int##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##
        ##nreg##nothing label##:
        ret [2 x i64] zeroinitializer

//@The function sets the current position in the file.
//@If the setting was successful, then the function returns "true", otherwise "false".
//@If the position is less than zero, the function returns an error with the "enum::STD::error_outOfRange" code.
//@If the first argument is in several places in the program, then the function returns an error with the code "enum::STD::error_notASingleCopy"
#alwaysinline
export def setFilePosition(file File, position Int) Bool
    inthrow
        if file.use?()
            throw(enum::error_notASingleCopy, "Not a single copy.")
        if position < 0
            throw(enum::error_outOfRange, "Out of range.")
    return unsafe_file_setFilePosition(file, position)

#alwaysinline nothrow
def unsafe_file_setFilePosition(file, position $Any) Bool
    llvm
        %##nreg##file memory## = extractvalue [2 x i64] %0, 1
        %##nreg##file memory i64*## = inttoptr i64 %##reg##file memory## to  i64*
        %##nreg##file pointer## = getelementptr i64, i64* %##reg##file memory i64*##, i64 1
        %##nreg##file i64## = load i64, i64* %##reg##file pointer##, align 8
        %##nreg##file## = inttoptr i64 %##reg##file i64## to i8*
        %##nreg##position## = extractvalue [2 x i64] %1, 1
        %##nreg##result i1## = call i1 @shar__set__position__in__file(i8* %##reg##file##, i64 %##reg##position##)
        %##nreg##result i64## = zext i1 %##reg##result i1## to i64
        %##nreg##result## = insertvalue [2 x i64] [i64 ##tnum##STD::Bool##, i64 0], i64 %##reg##result i64##, 1
        ret [2 x i64] %##reg##result##
