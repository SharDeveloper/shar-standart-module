module Main

def testThreads(write ok Int, write errorsCoordinates List)
    testThreads_Multithreaded(ok, errorsCoordinates)
    testThreads_Pipeline(ok, errorsCoordinates)
    testThreads_Worker(ok, errorsCoordinates)

#noinline
def testThreads_Multithreaded(write ok Int, write errorsCoordinates List)
    var s1 String = "123".clone()
    const s2 String = s1
    var s3 String = "".clone()
    const s4 String = s3
    test: ok, errorsCoordinates
        true.prepareForThreads()
        false.prepareForThreads() == false
        [1, 2, 3].repackTo(Bytes).prepareForThreads() == [1, 2, 3].repackTo(Bytes)
        [1, 2, 3].repackTo(Bytes).prepareForThreads().unsafe_getI64(0).inRange?(0, 2)
        [].repackTo(Bytes).prepareForThreads() == [].repackTo(Bytes)
        [].repackTo(Bytes).prepareForThreads().unsafe_getI64(0).inRange?(0, 2)
        '1'.prepareForThreads() == '1'
        'f'.prepareForThreads() == 'f'
        12.prepareForThreads() == 12
        -123.prepareForThreads() == -123
        1.0.prepareForThreads() == 1.0
        -12.0.prepareForThreads() == -12.0
        "123".prepareForThreads() == "123"
        "123".prepareForThreads().unsafe_getI64(0) == 0
        "123".clone().prepareForThreads().unsafe_getI64(0) == 1
        s1.prepareForThreads().unsafe_getI64(0) == 1
        "".prepareForThreads() == ""
        "".prepareForThreads().unsafe_getI64(0) == 0
        "".clone().prepareForThreads().unsafe_getI64(0) == 1
        s3.prepareForThreads().unsafe_getI64(0) == 1
        s1.unsafe_getI64(0) == 2
        s2.unsafe_getI64(0) == 2
        s3.unsafe_getI64(0) == 2
        s4.unsafe_getI64(0) == 2
        intToTime(12).prepareForThreads() == intToTime(12)
        intToTime(0).prepareForThreads() == intToTime(0)
        yield().nothing?()
        sleep(1).nothing?()
        sleep(0).nothing?()

#noinline
def testThreads_Pipeline(write ok Int, write errorsCoordinates List)
    const p Pipeline = createPipeline()
    const pOut PipelineOut = p.getPipelineOut()
    const pIn PipelineIn = p.getPipelineIn()
    var s1 String = "123".clone()
    const s2 String = s1
    var s3 String = "".clone()
    const s4 String = s3
    var s5 String = "34".clone()
    test: ok, errorsCoordinates
        p.pop().nothing?()
        pOut.pop().nothing?()
        p.push(12).nothing?()
        pIn.push("123").nothing?()
        pIn.push("123").nothing?()
        pIn.push("123").nothing?()
        pIn.push(s1).nothing?()
        pIn.push(s1).nothing?()
        pIn.push(s4).nothing?()
        pIn.push(s4).nothing?()
        pIn.push(s5).nothing?()
        pIn.push(s5).nothing?()
        s1.unsafe_getI64(0) == 2
        s2.unsafe_getI64(0) == 2
        s3.unsafe_getI64(0) == 2
        s4.unsafe_getI64(0) == 2
        s5.unsafe_getI64(0) == 1
        p.pop() == 12
        p.pop() == "123"
        pOut.pop() == "123"
        pOut.pop().unsafe_getI64(0) == 0
        pOut.pop() == "123"
        pOut.pop().unsafe_getI64(0) == 1
        pOut.pop() == ""
        pOut.pop().unsafe_getI64(0) == 1
        pOut.pop() == "34"
        pOut.pop().unsafe_getI64(0) == 1
        p.pop().nothing?()
        pOut.pop().nothing?()
        pIn.push("123").nothing?()
        pOut.pop() == "123"
        pOut.wait(0) : error_outOfRange
        pOut.wait(-1) : error_outOfRange
        pOut.wait(-9223372036854775808) : error_outOfRange
    for :(counter Int = 0) counter < 65; counter++
        pIn.push(counter)
    var allOk Bool = true
    for :(counter Int = 0) counter < 65; counter++
        allOk = allOk && pOut.pop() == counter
    test: ok, errorsCoordinates
        allOk
        p.dump(0) == "Type: STD::Pipeline\n"
        p.dump(1) == "  Type: STD::Pipeline\n"
        pIn.dump(0) == "Type: STD::PipelineIn\n"
        pIn.dump(1) == "  Type: STD::PipelineIn\n"
        pOut.dump(0) == "Type: STD::PipelineOut\n"
        pOut.dump(1) == "  Type: STD::PipelineOut\n"

#noinline
def testThreads_Worker(write ok Int, write errorsCoordinates List)
    var in Pipeline = createPipeline()
    var out Pipeline = createPipeline()
    test: ok, errorsCoordinates
        worker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
        worker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
        worker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
    for :(counter Int = 1) counter < 1000; counter++
        in.push(counter).nothing?()
    var count Int = 0
    var allOk Bool = true
    for :(loopCounter Int = 0) loopCounter < 1000000; loopCounter++
        const value <>Int = out.pop()
        if value.nothing?()
            yield()
        else
            allOk = allOk && value.inRange?(-999, 0)
            if count == 998
                end loopCounter
            count++
        if loopCounter == 999999
            allOk = false
            end loopCounter
    test: ok, errorsCoordinates
        allOk
    in.push(-1)
    in.push(-1)
    in.push(-1)
    in = createPipeline()
    out = createPipeline()
    test: ok, errorsCoordinates
        waitWorker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
        waitWorker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
        waitWorker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
    for :(counter Int = 1) counter < 1000; counter++
        in.push(counter).nothing?()
    count = 0
    allOk = true
    for :(loopCounter Int = 0) loopCounter < 1000000; loopCounter++
        const value <>Int = out.pop()
        if value.nothing?()
            yield()
        else
            allOk = allOk && value.inRange?(-999, 0)
            if count == 998
                end loopCounter
            count++
        if loopCounter == 999999
            allOk = false
            end loopCounter
    test: ok, errorsCoordinates
        allOk
    in.push(-1)
    in.push(-1)
    in.push(-1)
    in = createPipeline()
    out = createPipeline()
    test: ok, errorsCoordinates
        activeWaitWorker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
        activeWaitWorker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
        activeWaitWorker(in.getPipelineOut(), out.getPipelineIn()).nothing?()
    for :(counter Int = 1) counter < 1000; counter++
        in.push(counter).nothing?()
    count = 0
    allOk = true
    for :(loopCounter Int = 0) loopCounter < 1000000; loopCounter++
        const value <>Int = out.pop()
        if value.nothing?()
            yield()
        else
            allOk = allOk && value.inRange?(-999, 0)
            if count == 998
                end loopCounter
            count++
        if loopCounter == 999999
            allOk = false
            end loopCounter
    test: ok, errorsCoordinates
        allOk
    in.push(-1)
    in.push(-1)
    in.push(-1)

#worker
def worker(in PipelineOut, out PipelineIn)
    for :(loop)
        const value <>Int = in.pop()
        if value.nothing?()
            yield()
        else
            if value == -1
                end loop
            out.push(!value)

#worker
def waitWorker(in PipelineOut, out PipelineIn)
    for :(loop)
        const value Int = in.wait(50)
        if value == -1
            end loop
        out.push(!value)

#worker
def activeWaitWorker(in PipelineOut, out PipelineIn)
    for :(loop)
        const value Int = in.activeWait()
        if value == -1
            end loop
        out.push(!value)
